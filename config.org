#+title: Emacs Configuration
#+author: Jamie Beardslee
#+email: jdb@jamzattack.xyz
#+property: header-args:emacs-lisp :tangle lisp/config.el :noweb yes :results none

This is my Emacs config file.  It is written in org-mode so that I can
brag about how dope org-mode is.  [[file:README.org][This file]] contains my main
configuration, which is tangled to [[file:lisp/config.el][config.el]].  [[file:init.el][init.el]] sets the
variable [[help:custom-file][custom-file]] to [[file:lisp/custom.el][custom.el]], loads [[file:lisp/config.el][config.el]], and then loads
[[file:lisp/custom.el][custom.el]].

Note: [[file:lisp/custom.el][custom.el]] should not be edited manually, as it is used by Emacs
for settings changed using the customisation interface.

My own packages and other things that I need to [[help:require][require]] are housed in
[[file:lisp][lisp/]].  I don't include the [[file:straight][straight/]] directory so the first startup
will take some time.

* Startup

Get some things out of the way early.  Without [[*Straight][straight]] or
[[*Use-package and dependencies][use-package]], none of this config would work.

** Straight

Install [[https://github.com/raxod502/straight.el][straight.el]].  It gets a lot of hype, so I'm trying to use it
instead of the built-in =package.el=.  It has a use-package keyword, so
you can simply (re)define a package like so:

#+begin_src emacs-lisp :tangle no
  (use-package package-name
    :straight
    (package-name :host gitlab
                  :repo "user/forked-package"
                  :branch "cool-new-feature"))
#+end_src

This snippet clones and loads straight, stolen from the README.

#+begin_src emacs-lisp
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  (with-eval-after-load 'straight
    (setq straight-vc-git-default-protocol 'ssh)
    (add-to-list 'straight-built-in-pseudo-packages 'org)
    (fset 'try #'straight-use-package))
#+end_src

** Use-package and dependencies

Install use-package using [[help:straight-use-package][straight-use-package]], and load both
[[help:use-package][use-package]] and [[help:bind-key][bind-key]].  Note [[help:bind-key][bind-key]] is a dependency of
[[help:use-package][use-package]], so I don't need to install it manually.

I also use use-package's =:delight= keyword, so install that as well.  I
don't need to use =(require delight)= as use-package handles that.

#+begin_src emacs-lisp
  (straight-use-package 'use-package)
  (straight-use-package 'delight)
  (setq use-package-compute-statistics t)
  (require 'use-package)
  (require 'bind-key)
#+end_src

** Fonts

The function [[help:set-up-fonts-please][set-up-fonts-please]] loads my [[file:lisp/fonts.el][font settings]].  Call it when
creating a new frame or starting emacs.

#+begin_src emacs-lisp
  (defun set-up-fonts-please ()
    "Load font settings in `user-emacs-directory'/lisp/fonts.el."
    (interactive)
    (load (expand-file-name "lisp/fonts.el" user-emacs-directory)))

  (add-hook 'server-after-make-frame-hook 'set-up-fonts-please)
  (add-hook 'window-setup-hook 'set-up-fonts-please)
#+end_src

** Keybindings

*** Prefix keys

A couple of prefix keys.  It's useful to set these up early, so that
you don't get any errors i.e "C-z is not a valid prefix key".

**** Remove =C-z=

Unbind =C-z= before anything else, so that I can use it as a prefix key.

#+begin_src emacs-lisp
  (global-unset-key (kbd "C-z"))
#+end_src

**** Alias =<menu>= to =C-x=

Make the menu key do the same as =C-x=.

#+begin_src emacs-lisp
  (bind-key "<menu>" ctl-x-map)
#+end_src

*** Reloading config file

Reload [[file:lisp/config.el][config file]] with =C-z C-r=.  This is done with [[help:bind-key][bind-key]] so that
it is recorded in the variable [[help:personal-keybindings][personal-keybindings]].

#+begin_src emacs-lisp
  (bind-key "C-z C-r" 'config-load)
#+end_src

* Built-in packages

This is the section for built-in packages.

** package.el

It's useful to keep =package.el= updated for the functions
[[help:describe-package][describe-package]] and [[help:list-packages][list-packages]].  All my packages are now installed
using [[*Straight][straight]], so disable the function [[help:package-install][package-install]].

#+begin_src emacs-lisp
  (use-package package
    :no-require t
    :config
    (setq package-archives
          '(("gnu" . "http://elpa.gnu.org/packages/")
            ("melpa" . "http://melpa.org/packages/")))
    (fmakunbound 'package-install))
#+end_src

** Major editing modes

Major modes for text editing.  For non-editing major modes, see
[[Applications]]

*** Org Mode

Open source blocks and stuff in the current window.  Use =TAB= from the
language's major mode inside source blocks.  Open everything in Emacs,
and use [[help:eww][eww]] for html instead of [[help:mhtml-mode][mhtml-mode]].

#+begin_src emacs-lisp
  (use-package org
    :defer t
    :custom
    (org-src-window-setup 'current-window)
    (org-src-tab-acts-natively t)
    (org-adapt-indentation nil)
    (org-hide-emphasis-markers t)
    (org-file-apps
     '((auto-mode . emacs)
       ("\\.x?html?\\'" . (lambda (file &optional ignore)
                            (eww-open-file file)))))
    :delight
    (org-src-mode " #+src")
    :config
    (defun org-insert-emacs-help (symbol)
      "Insert a help link to SYMBOL.

  Interactively, this prompts from all symbols in `obarray'."
      (interactive (list
                    (completing-read
                     "Help link: "
                     obarray
                     (lambda (sym)
                       (and (or (boundp sym)
                                (fboundp sym))
                            (not (keywordp sym)))))))
      (insert (format "[[help:%s][%s]]" symbol symbol)))
    :bind
    (:map org-mode-map
          ("M-h" . mark-paragraph)
          ("C-M-h" . org-mark-element)
          ("C-c h" . org-insert-emacs-help))
    ("C-c M-." . org-time-stamp))
#+end_src

**** Org Indent

I used to use [[help:org-indent-mode][org-indent-mode]] a while back, but ditched it for reasons
I can't remember.  I set the [[help:org-indent-indentation-per-level][indentation level]] to 1 character instead
of its default value of 2.  This helps to keep the text within a
manageable width and is probably the reason I disabled it.

I find org-mode looks a bit cleaner and more "open" with this mode
enabled.  Without it, the window can get cluttered pretty easily.

#+begin_src emacs-lisp
  (use-package org-indent
    :defer
    :delight
    :config
    (setq org-indent-indentation-per-level 1))
#+end_src

**** Org capture

Take notes in [[help:org-mode][org-mode]] with specific templates and write them to a
file.  Similar to [[help:remember][remember]].

#+begin_src emacs-lisp
  (use-package org-capture
    :custom
    (org-default-notes-file "~/org/notes.org")
    (org-capture-templates
     '(("t" "Todo")
       ("tt" "Misc." entry
        (file+headline "todo.org" "Miscellaneous")
        "* TODO %?\n\n%a\n")
       ("tu" "University" entry
        (file+headline "todo.org" "University")
        "* TODO %?\n\n%a\n")
       ("n" "Notes" entry
        (file+headline "notes.org" "Notes")
        "* %?\nEntered on %u\n\n%i\n\n%a\n")
       ("m" "Music" entry
        (file+headline "notes.org" "Music")
        "* %?\nEntered on %u\n\n%i\n")
       ("e" "Elisp" entry
        (file+headline "notes.org" "Emacs Lisp")
        "* %^{Title}\n\n#+begin_src emacs-lisp\n %i\n#+end_src\n")
       ("d" "Diary" entry
        (file "diary.org")
        "* %?\nEntered on %u\n\n")))
    (org-capture-bookmark nil)
    :bind
    ("C-x M-r" . org-capture))
#+end_src

**** Org babel

Work with code blocks.  The libraries all provide support for a
language so that you can run their source blocks with =C-c C-c=.

***** LilyPond

Execute LilyPond source blocks.  For notes about exporting to pdf, see
[[https://gitlab.com/jamzattack/lilypond/-/raw/master/org/lilypond.org][this org file]].  Only load it when lilypond is installed.

#+begin_src emacs-lisp
  (use-package ob-lilypond
    :when (executable-find "lilypond")
    :defer t
    :commands org-babel-execute:lilypond)
#+end_src

***** C

Execute C source blocks.  [[http://bellard.org/tcc/][TCC]] is a really fast compiler, so use it
instead of gcc if it's installed.

#+begin_src emacs-lisp
  (use-package ob-C
    :defer t
    :commands org-babel-execute:C
    :custom
    (org-babel-C-compiler
     (or (executable-find "tcc")
         "gcc")))
#+end_src

***** Scheme

Execute scheme source blocks.  This uses [[*Geiser][Geiser]] which is kind of
awkward and slow, but evaluating scheme is useful.

#+begin_src emacs-lisp
  (use-package ob-scheme
    :defer t
    :commands org-babel-execute:scheme)
#+end_src

***** Common Lisp

Execute Common Lisp source blocks.  This depends on [[*SLIME][Slime]], which
doesn't start automatically (see the variable [[help:slime-auto-start][slime-auto-start]]).

#+begin_src emacs-lisp
  (use-package ob-lisp
    :defer t
    :commands org-babel-execute:lisp)
#+end_src

***** Shell

Execute shell source blocks.  Autoload =sh=, =shell=, and =bash= functions.

#+begin_src emacs-lisp
  (use-package ob-shell
    :defer t
    :commands
    org-babel-execute:sh
    org-babel-execute:shell
    org-babel-execute:bash)
#+end_src

**** Org links

The library [[help:org-mode][org-mode]] uses to create and store links.  I bind =C-x M-l=
to generate a link from the current position.

#+begin_src emacs-lisp
  (use-package ol
    :bind
    ("C-x M-l" . org-store-link))
#+end_src

**** Org agenda

Use all files in [[help:org-directory][org-directory]] to get my agenda.  And don't disrupt my
window configuration.

#+begin_src emacs-lisp
  (use-package org-agenda
    :defer t
    :after org
    :custom
    (org-agenda-files '("~/org" "~/org/uni"))
    (org-agenda-window-setup 'current-window)
    :bind
    ("C-z C-a" . org-agenda))
#+end_src

**** Org publish

I use [[info:org#Publishing][org-publish]] for my websites.  This block has a lot going on:

1. I set some [[my-org-publish-default-options][default options]] for publishing projects.
2. I use a [[*Generate postamble][custom function]] to generate postamble.
3. Include my three sites in [[help:org-publish-project-alist][org-publish-project-alist]].

#+begin_src emacs-lisp
  (use-package ox-publish
    :defer t
    :config
    (use-package ox-jamzattack
      :demand
      :straight
      (ox-jamzattack :type git
                     :repo "git@jamzattack.xyz:ox-jamzattack.git"))
    <<my-org-html-postamble-format>>
    (defvar my-org-publish-default-options
      '(
        <<my-org-publish-default-options>>
        )
      "Default options for `org-publish-project-alist'.

  This variable must be spliced into `org-publish-project-alist'
  when set, i.e.
      (setq org-publish-project-alist
              `((\"project\"
                 ,@my-org-publish-default-options)))")
    (setq
     org-html-postamble t ; needed to use custom format
     org-export-headline-levels 6
     org-html-postamble-format
     (my-org-html-postamble-format
      "Author: %A")
     org-publish-timestamp-directory "~/.cache/org/timestamps/"
     org-html-head "<link rel=\"stylesheet\" type=\"text/css\" href=\"/style.css\"/>"
     org-publish-project-alist
     `(("blog"
        ,@my-org-publish-default-options
        :base-directory "~/jamzattack.xyz/blog"
        :with-toc t
        :publishing-directory "~/jamzattack.xyz/out/blog"
        :html-postamble-format ,(my-org-html-postamble-format
                                 "Author: %A"
                                 "Date: %d (modified %M)"
                                 "Top: <a href=\"/index.html\">The Yeet Log</a>")
        :sitemap-filename "index.org"
        :sitemap-title "The Yeet Log"
        :sitemap-format-entry
        (lambda (entry style project)
          (cond ((not (directory-name-p entry))
                 (format "%s [[file:%s][%s]]"
                         (format-time-string
                          "%Y-%m-%d"
                          (org-publish-find-date entry project))
                         entry
                         (org-publish-find-title entry project)))
                ((eq style 'tree)
                 ;; Return only last subdir.
                 (file-name-nondirectory (directory-file-name entry)))
                (t entry)))
        :sitemap-sort-files anti-chronologically)
       ("music"
        ,@my-org-publish-default-options
        :base-directory "~/jamzattack.xyz/music"
        :recursive t
        :html-postamble-format ,(my-org-html-postamble-format
                                 "Author: %A"
                                 "Top: <a href=\"/sitemap.html\">All projects</a>")
        :publishing-directory "~/jamzattack.xyz/out/music"
        :sitemap-title "My Music Projects")
       ("html"
        ,@my-org-publish-default-options
        :base-directory "~/jamzattack.xyz/html"
        :publishing-directory "~/jamzattack.xyz/out/html"))))
#+end_src

***** Generate postamble

A little function to generate postamble.

#+name: my-org-html-postamble-format
#+begin_src emacs-lisp :tangle no
  (defun my-org-html-postamble-format (&rest args)
    "Generate an html postamble using ARGS.

  This generates a paragraph for each item in ARGS.  For format
  strings, see the docstring of `org-html-postamble-format'."
    (unless args
      (setq args '("Author: %a <%e>")))
    (list (list "en"
                (mapconcat (lambda (str)
                             (format (cond
                                      ((string-match-p "%d" str)
                                       "<p class=\"date\">%s</p>")
                                      ((string-match-p "%A" str)
                                       "<p class=\"author\">%s</p>")
                                      (t
                                       "<p>%s</p>"))
                                     str))
                           args
                           "\n"))))
#+end_src

***** Default export options

A list of default export options.

#+name: my-org-publish-default-options
#+begin_src emacs-lisp :tangle no
  :auto-sitemap t
  :publishing-function org-html-publish-to-html
  :html-metadata-timestamp-format "%Y-%m-%d"
  :with-toc nil
  :with-email t
  :with-drawers nil
  :section-numbers nil
  :with-todo-keywords nil
#+end_src

*** Cc-mode

Set the C style to bsd, which uses tabs.  Use Java/Awk indentation for
Java/Awk files.

#+begin_src emacs-lisp
  (use-package cc-mode
    :defer t
    :custom
    (c-default-style '((java-mode . "java")
                       (awk-mode . "awk")
                       (other . "bsd"))))
#+end_src

*** Emacs Lisp mode

Make the scratch buffer use [[help:emacs-lisp-mode][emacs-lisp-mode]].  Note: Most of my Elisp
keybindings are now in my package [[https://git.jamzattack.xyz/selime][selime]].

#+begin_src emacs-lisp
  (use-package elisp-mode
    :custom
    (initial-major-mode 'emacs-lisp-mode)
    :delight
    (emacs-lisp-mode "el" :major)
    (inferior-emacs-lisp-mode "EL>" :major)
    :bind
    ("<C-M-backspace>" . backward-kill-sexp))
#+end_src

**** Find-func

A package that defines a few functions for editing Elisp source code.
It provides the function [[help:find-function-setup-keys][find-function-setup-keys]] which binds some
keys in [[help:ctl-x-map][ctl-x-map]], but I prefer to have them under =C-h=.

#+begin_src emacs-lisp
  (use-package find-func
    :defer t
    :bind
    (:map help-map
          ("C-l" . find-library)
          ("C-f" . find-function)
          ("C-v" . find-variable)
          ("C-k" . find-function-on-key)))
#+end_src

*** Typesetting

**** Nroff-mode

Set a compile-command hook for =nroff= files.  I usually use the ms
macros when writing something, but I usually just use org-mode anyway.

#+begin_src emacs-lisp
  (use-package nroff-mode
    :defer t
    :config
    <<nroff-mode-compile>>
    :hook (nroff-mode . nroff-mode-compile))
#+end_src

***** Compile Command

#+name: nroff-mode-compile
#+begin_src emacs-lisp :tangle no
  (defun nroff-mode-compile ()
    "Set the compile command for nroff files.

  It will choose the macro set based on the file extension."
    (let* ((in (buffer-file-name))
           (out (concat (file-name-sans-extension in)
                        ".pdf")))
      (setq-local
       compile-command
       (format "groff -%s -Tpdf '%s' > '%s'"
               (file-name-extension in) in out))))
#+end_src

**** LaTeX

Set a compile-command hook for latex files.  I prefer to write in
org-mode, but compiling latex on its own is sometimes useful.

#+begin_src emacs-lisp
  (use-package tex-mode
    :defer t
    :config
    <<latex-compile-command>>
    :hook (latex-mode . latex-compile-command))
#+end_src

***** Compile Command

#+name: latex-compile-command
#+begin_src emacs-lisp :tangle no
  (defun latex-compile-command ()
    "Set the compile command for latex files."
    (setq-local compile-command
                (format "pdflatex %s" buffer-file-name)))
#+end_src

** Minor modes

Minor modes that help with anything Emacs, be it programming, writing
emails, or anything else that Emacs can do.

*** Compile

Bind =C-z RET= to [[help:compile][compile]] and =f9= to [[help:recompile][recompile]] (like [[help:compile][compile]], but no need
to press =RET=).

Also provided by this library is [[help:compilation-shell-minor-mode][compilation-shell-minor-mode]], a minor
mode designed for [[*Shell][Shell]] that provides highlighting and navigation for
errors and warnings.  I enable it in both [[*Shell][Shell]] and [[*Eshell][Eshell]].

#+begin_src emacs-lisp
  (use-package compile
    :bind
    ("C-z C-m" . compile)
    ("<f9>" . recompile)
    :delight
    (compilation-shell-minor-mode " Â¢")	; "C" for compile...
    :hook
    (eshell-mode . compilation-shell-minor-mode)
    (shell-mode . compilation-shell-minor-mode))
#+end_src

*** Hi-lock

I often use =M-s h .= to see where variables, functions, etc. are used.
However, [[*Paredit][paredit]] remaps =M-s= to [[help:paredit-splice-sexp][paredit-splice-sexp]], so I turn on
[[help:hi-lock-mode][hi-lock-mode]] which enables the =C-x w= prefix.

#+begin_src emacs-lisp
  (use-package hi-lock
    :delight
    :config
    (global-hi-lock-mode t))
#+end_src

*** Parens

Highlight matching parens everywhere.

#+begin_src emacs-lisp
  (use-package paren
    :config
    (show-paren-mode t))
#+end_src

*** Auto fill

Instead of "Fill", show =^M= (carriage return) in the mode-line.

#+begin_src emacs-lisp
  (use-package simple
    :delight
    (auto-fill-function " ^M"))
#+end_src

*** Isearch

Instead of "ISearch", show =^S= (=C-s=) in the mode-line.

#+begin_src emacs-lisp
  (use-package isearch
    :delight " ^S")
#+end_src

*** Eldoc

Eldoc is what provides the function signature in the mode-line when
editing Elisp.  By default, it waits for 0.5 seconds so I bump the
delay down to 0.1.

#+begin_src emacs-lisp
  (use-package eldoc
    :delight
    :defer t
    :custom
    (eldoc-idle-delay 0.1))
#+end_src

** Applications

This section is for Elisp programs that have an interface of their
own, rather than being just a major/minor mode.

*** EWW

Elisp web browser - I just set some variables to make eww the default
browser, and change the width to 80 columns.

#+begin_src emacs-lisp
  (use-package eww
    :defer t
    :custom
    (eww-bookmarks-directory
     (expand-file-name "eww" user-emacs-directory))
    (eww-browse-url-new-window-is-tab nil)
    :init
    (with-eval-after-load 'browse-url
      (setq browse-url-browser-function 'eww-browse-url
            browse-url-secondary-browser-function 'browse-url-externally-please))
    <<browse-url-externally-please>>
    :config
    <<eww-edit-current-url>>
    <<eww-set-width>>
    :bind
    (:map eww-mode-map
          ("M-n" . forward-paragraph)
          ("M-p" . backward-paragraph)
          ("e" . eww-edit-current-url)
          ("V" . variable-pitch-mode)
          ("C-x f" . eww-set-width)
          ;; plumb
          ("f" . plumb-stream)
          ("D" . plumb-download-video)
          ("A" . plumb-audio)
          ;; transmission
          ("m" . transmission-add-url-at-point)
          ;; helm-eww
          ("B" . helm-eww-bookmarks)
          ("H" . helm-eww-history)
          ("s" . helm-eww-buffers)))
#+end_src

**** External browser

#+name: browse-url-externally-please
#+begin_src emacs-lisp :tangle no
  (defun browse-url-externally-please (url &optional ignored)
    "Open URL using either vimb or surf if they are found,
  otherwise use xdg-open."
    (interactive (browse-url-interactive-arg "URL: "))
    (call-process (or (executable-find "vimb")
                      (executable-find "surf")
                      (executable-find "xdg-open"))
                  nil 0 nil url))
#+end_src

**** Edit current URL

Useful command to edit the current URL.  With prefix arg, open the
edited URL in a new buffer.  Bound to =e= in eww-mode.

#+name: eww-edit-current-url
#+begin_src emacs-lisp :tangle no
  (defun eww-edit-current-url (&optional arg)
    "Edit the current URL.
  With prefix ARG, open in a new buffer."
    (interactive "p")
    (let ((url
           (read-string (if (= arg 1)
                            "URL: "
                          "URL (new buffer): ")
                        (eww-current-url))))
      (eww url arg)))
#+end_src

**** Set eww width

This command sets [[help:shr-width][shr-width]] to a value read from the minibuffer.  Very
useful in eww, and a fitting replacement for [[help:set-fill-column][set-fill-column]].

#+name: eww-set-width
#+begin_src emacs-lisp :tangle no
  (defun eww-set-width (width)
    "Set the html rendering width to WIDTH.

  If prefix arg is a number, use it.  Otherwise, read number from
  the minibuffer."
    (interactive (list
                  (if (numberp current-prefix-arg)
                      current-prefix-arg
                    (read-number "Set width: "
                                 (- (window-width) 5)))))
    (setq shr-width width)
    (eww-reload t))
#+end_src

*** SHR

#+begin_src emacs-lisp
  (use-package shr
    :defer t
    :custom
    (shr-width 80)
    :config
    <<un-duckduckgo-url>>
    :bind
    (:map shr-map
          ("f" . plumb-stream)
          ("A" . plumb-audio)
          ("D" . plumb-download-video)))
#+end_src

**** Remove duckduckgo tracking from url

Duckduckgo does a very sinful thing -- instead of linking to
=https://url.com=, it links to:
: https://duckduckgo.com/l/?kh=-1&uddg=https%3A%2F%2Furl.com

Here, I define a function that removes all this junk, and use [[info:elisp#Advising Named Functions][advice]]
to filter the arguments given to [[help:shr-urlify][shr-urlify]].  Because this is
relatively low-level, all occurences of duckduckgo's redirects that
are parsed with =shr= are replaced with the clean version.

#+name: un-duckduckgo-url
#+begin_src emacs-lisp :tangle no
  (defun un-duckduckgo-url (args)
    "Cleanse a url from duckduckgo's janky redirect.
  This takes the same args as `shr-urlify', passed as a list."
    (let ((start (nth 0 args))
          (url (nth 1 args))
          (title (nth 2 args)))
      (list start
            (let ((unhexed (url-unhex-string url)))
              (if (string-match "\\`.*&uddg=" unhexed)
                  (replace-match "" nil nil unhexed)
                url))
            title)))

  (advice-add 'shr-urlify :filter-args #'un-duckduckgo-url)
#+end_src

*** ERC

The only reason for this to be here is to set my nick.

#+begin_src emacs-lisp
  (use-package erc
    :defer t
    :custom
    (erc-nick "jamzattack")
    (erc-hide-list '("JOIN" "PART" "QUIT"))
    :config
    (add-to-list 'erc-modules 'notifications)
    (erc-track-mode))
#+end_src

**** ERC notifications

[[help:erc-notify-enable][erc-notify]] enables notifications for erc conversations.  I only enable
it if the executable "dunst" is found, because it will crash Emacs
unless a notification daemon is active.

#+begin_src emacs-lisp
  (use-package erc-notify
    :after erc
    :config
    (when (executable-find "dunst")
      (erc-notify-enable)))
#+end_src

*** Info

Rebind M-p and M-n to move by paragraphs.  By default M-n runs
[[help:clone-buffer][clone-buffer]], which I find to be completely useless.

#+begin_src emacs-lisp
  (use-package info
    :bind
    (:map Info-mode-map
          ("M-p" . backward-paragraph)
          ("M-n" . forward-paragraph)))
#+end_src

*** Ibuffer

Ibuffer is an interface similar to dired, but for editing your open
buffers.  I don't use it much now in favour of [[*HELM][Helm]], but it can be
useful for more complex filtering.

#+begin_src emacs-lisp
  (use-package ibuffer
    :bind
    ("C-x C-b" . ibuffer)
    :init
    (defun ibuffer-helm-major-mode-predicate (buffer)
      "Returns t if BUF is a helm buffer."
      (equal 'helm-major-mode
             (with-current-buffer buffer
               major-mode)))
    :config
    (add-to-list 'ibuffer-maybe-show-predicates
                 #'ibuffer-helm-major-mode-predicate))
#+end_src

*** Dired

Group directories first.  This works only with GNU ls, so don't use
this if you use a different version.

#+begin_src emacs-lisp
  (use-package dired
    :defer t
    :config
    (setq dired-listing-switches "-lahv --group-directories-first")
    :init
    (setq delete-by-moving-to-trash t))
#+end_src

**** Dired-x

I load [[info:dired-x#Top][dired-x]] after dired, to enable some useful commands such as
[[help:dired-mark-extension][dired-mark-extension]] and [[help:dired-mark-sexp][dired-mark-sexp]].

I bind =C-x C-d= to [[help:dired-jump][dired-jump]], instead of the useless [[help:list-directory][list-directory]].

#+begin_src emacs-lisp
  (use-package dired-x
    :after dired
    :demand t
    :bind
    ("C-x C-d" . dired-jump))
#+end_src

*** Diffing

**** Ediff

By default, [[info:ediff#Top][Ediff]] tries to open its own frame.  This doesn't work well
with EXWM, so I disable that feature.

#+begin_src emacs-lisp
  (use-package ediff
    :defer t
    :custom
    (ediff-window-setup-function
     #'ediff-setup-windows-plain))
#+end_src

**** Smerge

Easily merge git conflicts.  The prefix is =C-c ^= which works fine, but
I also bind =C-c n= and =C-c p= to go to the next/previous hunk.

#+begin_src emacs-lisp
  (use-package smerge-mode
    :bind
    (:map smerge-mode-map
          ("C-c n" . smerge-next)
          ("C-c p" . smerge-prev)))
#+end_src

** Shells

Shells in Emacs - both shell and eshell settings are here.

*** Shell

I don't want the shell buffer to open a new window, so add an entry in
[[help:display-buffer-alist][display-buffer-alist]].

#+begin_src emacs-lisp
  (use-package shell
    :defer t
    :config
    (add-to-list 'display-buffer-alist
                 '("\\`\\*shell\\*\\'" display-buffer-same-window)))
#+end_src

*** Eshell

A bunch of new eshell functions for my convenience; see their
docstrings or org headings for more details.

Much of my eshell workflow is now housed in [[*Eshell outline mode][Eshell outline mode]], so a
few customisations have been removed recently.

#+begin_src emacs-lisp
  (use-package eshell
    :custom
    (eshell-history-size 10000)
    :init
    <<open-or-bury-eshell>>
    :bind
    ("s-e" . open-or-bury-eshell)
    ("s-E" . switch-to-eshell)
    (:map eshell-mode-map
          ("C-c r" . eshell/r))
    :config
    (require 'esh-mode)
    <<eshell/e>>
    <<eshell/r>>
    <<eshell/ssh>>
    <<eshell/c>>
    <<eshell/h>>
    <<eshell/su>>
    <<eshell/comint>>)
#+end_src

**** Eshell functions

***** Open or bury eshell

Open an eshell buffer or bury the current one.

#+name: open-or-bury-eshell
#+begin_src emacs-lisp :tangle no
  (defun switch-to-eshell (name)
    "Switch to or create an eshell buffer called NAME."
    (interactive (list
                  (read-buffer
                   "Switch to eshell: " "*eshell*" nil
                   (lambda (buffer)
                     (eq (buffer-local-value
                          'major-mode (get-buffer buffer))
                         'eshell-mode)))))
    (with-current-buffer (get-buffer-create name)
      (unless (derived-mode-p 'eshell-mode)
        (eshell-mode))
      (switch-to-buffer (current-buffer))))

  (defun open-or-bury-eshell (&optional arg)
    "Open or bury an eshell.

  If prefix ARG is (16) i.e. C-u C-u, call `switch-to-eshell'.  If
  the current buffer is an eshell, bury it."
    (interactive "P")
    (cond ((equal arg '(16))
           (call-interactively #'switch-to-eshell))
          ((or arg (not (derived-mode-p 'eshell-mode)))
           (eshell arg))
          (t
           (bury-buffer))))
#+end_src

***** Edit a file

Instead of opening a file with =emacsclient=, just edit it directly.

#+name: eshell/e
#+begin_src emacs-lisp :tangle no
  (defun eshell/e (&rest args)
    "Edit a file from eshell."
    (mapcar 'find-file args))
#+end_src

***** Comint

A wrapper to start a comint process from eshell.

Used like so:
#+begin_example sh
comint ed ~/.bashrc
#+end_example

#+name: eshell/comint
#+begin_src emacs-lisp :tangle no
  (defun eshell/comint (&rest args)
    "Start a comint session running ARGS"
    (let ((string (eshell-flatten-and-stringify args))
          (program (executable-find (car args)))
          (program-args (eshell-flatten-and-stringify (cdr args))))
      (switch-to-buffer
       (make-comint string
                    (or program
                        (user-error "Executable %s not found" (car args)))
                    nil
                    program-args))))
#+end_src

***** ssh via tramp

A simple ssh wrapper that uses tramp.  ~ssh user@host~ will always be
run as the current user via local ssh.

#+name: eshell/ssh
#+begin_src emacs-lisp :tangle no
  (defun eshell/ssh (&rest args)
    "Use tramp to move into an ssh directory.

  Usage: ssh [USER@]HOST [PATH]"
    (let ((host (car args))
          (path (or (cadr args) "")))
      (eshell/cd (format "/ssh:%s:%s" host path))))
#+end_src

***** su via tramp

A simple sudo wrapper that uses tramp.  Works from remote hosts as
well.

#+name: eshell/su
#+begin_src emacs-lisp :tangle no
  (defun eshell/su (&rest args)
    (let ((user (or (car args) "root")))
      (eshell/cd
       (if (string-prefix-p "/ssh:" default-directory)
           (format (replace-regexp-in-string
                    "/ssh:\\(.*@\\)?:?+\\(.*\\):.*" ;regex
                    "/ssh:\\1\\2|sudo:%s@\\2:"	  ;replacement
                    default-directory)		  ;string
                   user)
         (format "/sudo:%s@localhost:" user)))))
#+end_src

***** Describe symbol

A wee eshell interface to [[help:helpful-symbol][helpful-symbol]].  Falls back to
[[help:describe-symbol][describe-symbol]] if the above isn't available somehow.

#+name: eshell/h
#+begin_src emacs-lisp :tangle no
  (defun eshell/h (symbol-name &rest _ignored)
    "Show help for SYMBOL-NAME.

  If `helpful-symbol' is available, use it.  Otherwise, fall back
  to `describe-symbol'."
    (let ((function (if (fboundp 'helpful-symbol)
                        #'helpful-symbol
                      #'describe-symbol)))
      (funcall function (intern symbol-name))))
#+end_src

***** Rename eshell buffer

Rename the current eshell.  Bound to =C-c r=, but can also be used from
eshell with or without an argument.
#+begin_example
  r "my buffer's new name"
#+end_example

With an argument, the buffer will be renamed that argument.  This is
achieved interactively with a prefix argument.

Otherwise, it will be named according to:
- The current process
- TRAMP user@host
- The current working directory

#+name: eshell/r
#+begin_src emacs-lisp :tangle no
  (defun eshell/r (&optional name &rest _ignored)
    "Rename the current buffer.

  This will be (in order):
  - [eshell] the first argument
  - [interactive] numeric prefix arg
  - [interactive] read from minibuffer with non-numeric prefix arg
  - the current process
  - the TRAMP user@host
  - the current working directory

  If a buffer of the chosen name already exists, rename it
  uniquely."
    (interactive (list (let ((arg current-prefix-arg))
                         (cond
                          ((numberp arg)
                           arg)
                          (arg
                           (read-string "New name: "))))))
    (setq name
          (if (numberp name)
              ;; If NAME is a number (either from eshell or via prefix
              ;; arg), format it like eshell does.
              (format "<%d>" name)
            ;; Otherwise, add an extra space before.
            (format " %s"
                    (or
                     name
                     (let ((proc (eshell-interactive-process)))
                       (when proc
                         (process-name proc)))
                     (let ((dir (eshell/pwd)))
                       (if (string-match-p tramp-file-name-regexp dir)
                           (replace-regexp-in-string
                            ".*:\\(.*\\):.*" "\\1" dir)
                         (replace-regexp-in-string
                          abbreviated-home-dir "~/" dir)))))))
    (let ((buffer
           (concat eshell-buffer-name name)))
      (rename-buffer buffer (get-buffer buffer))))
#+end_src

***** eshell/c

[[help:eshell/c][eshell/c]] is a super beefy function that supersedes [[help:eshell/cat][eshell/cat]].  It
uses the GUI to its advantage to show:
- [[help:eshell/img][images]]
- [[help:eshell/ls][directories]]
- [[help:eshell/shr][rendered html]]
- [[help:eshell/fontify][fontified source code]]

#+name: eshell/c
#+begin_src emacs-lisp :tangle no
  (defun eshell/img (&rest files)
    "Insert FILES into the buffer as images.

  If a file does not match `image-file-name-regexp', nothing
  happens."
    (dolist (file (mapcar #'expand-file-name (flatten-tree files)))
      (when (string-match-p (image-file-name-regexp) file)
        (goto-char (1- (point)))
        (insert "\n")
        (insert-image (create-image file nil nil
                                    :max-height (* 2 (/ (window-pixel-height) 3))
                                    :max-width (* 2 (/ (window-pixel-width) 3))))))
    (goto-char (point-max))
    nil)

  (defun eshell/shr (&rest files)
    "Insert FILES into the buffer as rendered HTML."
    (dolist (file (mapcar #'expand-file-name (flatten-tree files)))
      (when (string-match-p "\\.html\\'" file)
        (goto-char (1- (point)))
        (shr-insert-document
         (with-temp-buffer
           (insert-file-contents file)
           (libxml-parse-html-region (point-min) (point-max))))))
    (goto-char (point-max))
    nil)

  (defun eshell/fontify (&rest files)
    "Insert FILES into the buffer.

  Like `eshell/cat', but fontifies the text as it would be if it
  were visited normally."
    (dolist (file (mapcar #'expand-file-name (flatten-tree files)))
      (goto-char (1- (point)))
      (insert "\n")
      (insert
       (with-temp-buffer
         (insert-file-contents file)
         (setq buffer-file-name file)
         (normal-mode)
         (font-lock-ensure)
         (delete-region (1- (point-max)) (point-max))
         (set-buffer-modified-p nil)
         (buffer-string)))
      (goto-char (point-max)))
    nil)

  (defun eshell/c (&rest files)
    "My overpowered version of `eshell/cat'.

  This command show FILES as:
  - images (`eshell/img')
  - directories (`eshell/ls')
  - rendered html (`eshell/shr')
  - fontified source code (`eshell/fontify')"
    (dolist (file (mapcar (lambda (file)
                            (let ((expanded (expand-file-name file)))
                              (when (file-exists-p file)
                                expanded)))
                          (flatten-tree files)))
      (cond ((string-match-p (image-file-name-regexp) file)
             (eshell/img file))
            ((file-directory-p file)
             (eshell/ls "-lah" file))
            ((string-match-p "\\.html\\'" file)
             (eshell/shr file))
            (t
             (eshell/fontify file)))))
#+end_src

** Saving the state of Emacs

Packages that save where you were - recentf saves a list of edited
files, and desktop saves a list of variables and current buffers.

*** Recentf

This package saves a list of recently visited files.  I've had some
problems with Helm not loading the recentf list, so it is done here.

#+begin_src emacs-lisp
  (use-package recentf
    :config (recentf-load-list))
#+end_src

*** Desktop

Save list of buffers and some variables when exiting Emacs.  Don't
save a list of frames, that just ends up spamming me with extra frames
everywhere.

#+begin_src emacs-lisp
  (use-package desktop
    :custom
    (desktop-restore-frames nil)
    (history-delete-duplicates t)
    (desktop-save-mode t)
    :config
    (add-to-list 'desktop-globals-to-save 'helm-ff-history)
    (add-to-list 'desktop-globals-to-save 'extended-command-history))
#+end_src

*** Save Place

Like [[*Desktop][desktop-save-mode]], but saves the place in buffers between Emacs
sessions, rather than the list of buffers.

#+begin_src emacs-lisp
  (use-package saveplace
    :config
    (save-place-mode t))
#+end_src

*** Winner-mode

Saves window configurations so that you can use =C-c <left>= to undo
changes in window arrangement.

#+begin_src emacs-lisp
  (use-package winner
    :config
    (winner-mode))
#+end_src

** Interface tweaks

Some settings for the UI of Emacs - mode-line, scroll-bar, etc.

*** Extraneous bars

Section for the three wasteful bars -- tool bar, menu bar, and scroll
bar.

**** Scroll bar

Disable the scroll bar using =customize=, but set the width in case I
decide to turn it on.

#+begin_src emacs-lisp
  (use-package scroll-bar
    :custom
    (scroll-bar-mode nil)
    (scroll-bar-width 6 t))
#+end_src

**** Menu bar

Disable the menu bar.

#+begin_src emacs-lisp
  (use-package menu-bar
    :config
    (menu-bar-mode -1))
#+end_src

**** Tool bar

Disable the tool bar.

#+begin_src emacs-lisp
  (use-package tool-bar
    :config
    (tool-bar-mode -1))
#+end_src

*** Mode-line

**** Time

Display the current time in the mode-line, and make it use 24-hour
time.

#+begin_src emacs-lisp
  (use-package time
    :custom
    (display-time-24hr-format t)
    :config
    (display-time-mode t))
#+end_src

**** Battery

Show battery information with =C-z b=.  Configuration for showing
battery status in the mode-line is in a separate [[*Battery info in mode-line][heading]].

#+begin_src emacs-lisp
  (use-package battery
    :config
    <<battery-mode-line>>
    :bind
    ("C-z b" . battery)
    ("<XF86Battery>" . battery))
#+end_src

***** Battery info in mode-line

Every time [[help:battery][battery]] is called (with =C-z b=), check if
[[help:display-battery-mode][display-battery-mode]] should be turned on or off.

I also adjust [[help:battery-mode-line-format][battery-mode-line-format]] to add an extra space between
the battery and time.  By default, these push up against each other
which I do not like.

#+name: battery-mode-line
#+begin_src emacs-lisp :tangle no
  (setq battery-mode-line-format " [%b%p%%]")

  (defun set-display-battery-mode-accordingly ()
    "Enable `display-battery-mode' if battery is being used.
  If connected to power, or no battery is detected, disable it."
    (if (and battery-status-function
             (rassoc "discharging" (funcall battery-status-function)))
        (display-battery-mode t)
      (display-battery-mode 0)))

  (advice-add 'battery :after #'set-display-battery-mode-accordingly)
#+end_src

**** Show the column

Show the current column in the mode-line.  This is provided by the
=simple= package.

#+begin_src emacs-lisp
  (use-package simple
    :config
    (column-number-mode t))
#+end_src

*** Indicate empty lines

This displays a bunch of little lines in the fringe where there are
empty lines.  I decided that I want more stuff in my fringe, and have
been experimenting with it recently.

It's entirely useless in non-editing modes, so I add it only to
[[help:prog-mode-hook][prog-mode-hook]] and [[help:text-mode-hook][text-mode-hook]].

The state is actually controlled by the buffer-local variable
[[help:indicate-empty-lines][indicate-empty-lines]].  In order to add it to hooks, I need to define a
wrapper function (although called [[help:indicate-empty-lines-mode][indicate-empty-lines-mode]], this
function is not officially a minor mode--I just named it such for
consistency's sake).

#+begin_src emacs-lisp
  (defun indicate-empty-lines-mode (&optional arg)
    "Indicate empty lines in the fringe.

  This is not actually a minor mode, just a wrapper function to set
  the variable `indicate-empty-lines'.

  If called interactively, enable indicaty-empty-lines-mode if ARG
  is positive, and disable it if ARG is zero or negative.  If
  called from Lisp, also enable the mode if ARG is omitted or nil,
  and toggle it if ARG is toggle; disable the mode otherwise."
    (interactive (list (or current-prefix-arg 'toggle)))
    (setq indicate-empty-lines
          (cond ((eq arg 'toggle)
                 (not indicate-empty-lines))
                ((numberp arg)
                 (< 1 arg))
                (t t))))

  (add-hook 'text-mode-hook #'indicate-empty-lines-mode)
  (add-hook 'prog-mode-hook #'indicate-empty-lines-mode)
#+end_src

*** Keybindings

A couple of keybindings to change the way lines are displayed.

**** Line wrapping

Simple keybinding to wrap/unwrap lines.  This feature is also provided
by =simple=.

#+begin_src emacs-lisp
  (use-package simple
    :bind
    ("C-c t" . toggle-truncate-lines))
#+end_src

**** Line numbers

Display line numbers.  I prefer to just use the mode-line because it
doesn't slow down Emacs as much.

#+begin_src emacs-lisp
  (use-package display-line-numbers
    :bind
    ("C-c l" . display-line-numbers-mode))
#+end_src

**** Cycle spacing

By default, =M-SPC= is bound to the less powerful [[help:just-one-space][just-one-space]].  I
rebind that key to [[help:cycle-spacing][cycle-spacing]], which does the same thing but on
successive invocations switches between one space and no spaces.
Thus, =M-SPC M-SPC= acts like =M-\= ([[help:delete-horizontal-space][delete-horizontal-space]])

#+begin_src emacs-lisp
  (use-package simple
    :bind
    ("M-SPC" . cycle-spacing))
#+end_src

*** Minibuffer

I set the variable [[help:enable-recursive-minibuffers][enable-recursive-minibuffers]] to allow recursive
minibuffers.  e.g. =M-!= rm -rf =C-u M-:= user-emacs-directory =RET= =RET=

The library =mb-depth= provides a [[help:minibuffer-depth-indicate-mode][minor mode]] that that shows how deep
you are in the minibuffer "stack".

#+begin_src emacs-lisp
  (use-package mb-depth
    :config
    (setq enable-recursive-minibuffers t)
    (minibuffer-depth-indicate-mode))
#+end_src

** Environment variables

Set the =$EDITOR= to =emacsclient=.  Because I (almost) only use other
programs from within Emacs, this works.  If you don't use EXWM it
would be advisable to set this in =~/.xinitrc=.  Also set =$PAGER= to =cat=
for programs launched from Emacs, helpful with eshell because some
programs automatically output to the pager.

#+begin_src emacs-lisp
  (use-package env
    :config
    (setenv "EDITOR" "emacsclient")
    (setenv "PAGER" "cat"))
#+end_src

** Windows

Libraries related to Emacs windows.  Not to be confused with the
operating system.

*** Window

[[help:bury-buffer][bury-buffer]] is a very useful function so I bind it to =C-z C-z=, a
pretty accessible key.

For purely pedantic reasons, I also bind =C-x _= to [[help:shrink-window][shrink-window]].  Why
does [[help:shrink-window-horizontally][shrink-window-horizontally]] have a keybinding by default but
[[help:shrink-window][shrink-window]] doesn't?

A further useful keybinding is for [[help:quit-window][quit-window]], which sometimes isn't
bound even when it should be.  I bind it to =s-DEL=.

I set the variable [[help:switch-to-prev-buffer-skip][switch-to-prev-buffer-skip]] to a custom function,
which means that [[help:switch-to-prev-buffer][switch-to-prev/next-buffer]] and [[help:bury-buffer][bury-buffer]] won't
switch to a buffer that I consider boring.  This includes:
- helm, helpful, help buffers
- empty buffers (but _not_ exwm buffers)

#+begin_src emacs-lisp
  (use-package window
    :no-require
    :demand
    :bind
    ("C-z C-z" . bury-buffer)
    ("C-x _" . shrink-window)
    ("<s-backspace>" . quit-window)
    ("s-s" . next-buffer)
    ("s-d" . previous-buffer)
    :config
    (defun skip-boring-buffer-please (_window buffer _bury-or-kill)
      "Return non-nil if BUFFER is boring.
  A buffer is \"boring\" if one of the following is true:
  - it is in `helm-major-mode', `helpful-mode', or `help-mode'
  - it is empty
  - it is _not_ in `exwm-mode'"
      (or (member (buffer-local-value 'major-mode buffer)
                  '(helm-major-mode
                    helpful-mode
                    help-mode))
          (unless
              (equal (buffer-local-value 'major-mode buffer)
                     'exwm-mode)
            (with-current-buffer buffer
              (= (point-min) (point-max))))))
    (setq switch-to-prev-buffer-skip
          #'skip-boring-buffer-please))
#+end_src

*** Windmove

Bind =s-{c,h,t,n}= to switch window more easily.  I use dvorak, so this
is like ={i,j,k,l}= on a qwerty keyboard.  The shifted keys swap rather
than moving.

#+begin_src emacs-lisp
  (use-package windmove
    :defer t
    :bind
    ("s-c" . windmove-up)
    ("s-h" . windmove-left)
    ("s-t" . windmove-down)
    ("s-n" . windmove-right)
    ("s-C" . windmove-swap-states-up)
    ("s-H" . windmove-swap-states-left)
    ("s-T" . windmove-swap-states-down)
    ("s-N" . windmove-swap-states-right))
#+end_src

*** Tab-bar

I've started using [[help:tab-bar-mode][tab-bar-mode]] instead of exwm workspaces.  I don't
like the tab bar to be shown all the time, so I hide it.

I also add advice to show the current tab and index in the echo area.
Somewhat awkwardly, a similar message is also shown by default when
[[help:tab-bar-mode][tab-bar-mode]] is nil.  I prefer my less subtle message, but I might
remove this in the future -- maybe show it in the mode-line instead?

The keybindings =s-g= and =s-r= move to the previous or next tab
respectively, which fits well with my windmove keybindings.  =s-w= is
the default keybinding in exwm to switch workspace, so I reuse the key
to switch tab.

#+begin_src emacs-lisp
  (use-package tab-bar
    :defer t
    :custom
    (tab-bar-show nil)
    (tab-bar-close-button-show nil)
    (tab-bar-new-button-show nil)
    (tab-bar-tab-hints t)
    :bind
    ("s-g" . tab-previous)
    ("s-r" . tab-next)
    ("s-w" . tab-bar-switch-to-tab)
    :config
    (dolist (k (number-sequence 0 9))
      (bind-key (kbd (format "s-%s" k)) 'tab-bar-select-tab))
    (defadvice tab-bar-select-tab
        (after show-tab-name activate)
      "Show the tab name and index+1 in the echo area."
      (message "Switched to tab: %s (%s)"
               (propertize
                (cdr (assoc 'name (tab-bar--tab)))
                'face 'error)
               (1+ (tab-bar--current-tab-index)))))
#+end_src

** View-mode

I like using view-mode and scroll-lock-mode is kind-of useless, so I
rebind Scroll_Lock to toggle view-mode and enable view-mode if a
buffer is read-only.

Also bind some keys to simplify movement.

#+begin_src emacs-lisp
  (use-package view
    :custom (view-read-only t)
    :bind
    ("<Scroll_Lock>" . view-mode)
    (:map view-mode-map
          ("l" . recenter-top-bottom)
          ("f" . forward-sexp)
          ("b" . backward-sexp)))
#+end_src

** Fixing some default behaviour

Tweak some default behaviour that pisses me off.

*** Swap yes/no prompt with y/n

Typing yes/no is an inconvenience that can be avoided.  Alias it to
y/n.  This would be wrapped in =(use-package subr ...)= but that isn't
requirable.

#+begin_src emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
  (bind-key "RET" 'y-or-n-p-insert-y y-or-n-p-map)
#+end_src

*** Enable all the features

Disable the annoying "This is an advanced feature" thing.  It seems so
dumb that this feature exists.

#+begin_src emacs-lisp
  (use-package novice
    :custom
    (disabled-command-function nil))
#+end_src

*** Disable audible and visual bell

Don't ring the damn bell.  This is provided by the file "terminal.c"
which isn't a loadable feature, so use custom instead.

#+begin_src emacs-lisp
  (use-package custom
    :custom
    (ring-bell-function 'ignore))
#+end_src

** Theme

Allow themes to be loaded from the [[file:lisp/themes][lisp/themes]] directory, allow all
themes to be loaded, then load my [[file:lisp/themes/custom-theme.el][custom theme]].

#+begin_src emacs-lisp
  (use-package custom
    :custom
    (custom-theme-directory
     (expand-file-name "lisp/themes" user-emacs-directory))
    (custom-safe-themes t)
    (custom-enabled-themes '(custom)))
#+end_src

** Convenience

Some convenience features.

*** Hippie expand

Hippie-expand is a slightly more useful replacement for
dabbrev-expand.  It can make use of multiple sources, including
filenames, kill-ring, and dabbrev.

#+begin_src emacs-lisp
  (use-package hippie-exp
    :defer t
    :bind
    ("M-/" . hippie-expand))
#+end_src

*** Paragraphs

Bind =M-n= and =M-p= to move by paragraph.  I used to do this on a
per-mode basis, but that got annoying.  These functions are defined in
=paragraphs.el= which isn't a loadable feature, so I use =(use-package
emacs)= instead.

#+begin_src emacs-lisp
  (use-package emacs
    :bind
    ("M-n" . forward-paragraph)
    ("M-p" . backward-paragraph))
#+end_src

*** Project

[[info:emacs#Projects][project.el]] is Emacs' builtin library of convenience functions for
working on a "project", which is really just a directory with version
control.

By default, the project-specific Eshells open in another window, so I
adjust [[help:display-buffer-alist][display-buffer-alist]] to display them in the [[help:display-buffer-same-window][same window]].

#+begin_src emacs-lisp
  (use-package project
    :defer t
    :config
    (add-to-list 'display-buffer-alist
                 '("-eshell\\*\\'" display-buffer-same-window)))
#+end_src

** Mail

*** Gnus

I've finally managed to make the switch to gnus.  Frankly, my main
motivation was to avoid setting up notmuch again with my university
email.

As far as I can tell, using a maildir with gnus is a hassle -- so I'm
just using IMAP.

#+begin_src emacs-lisp
  (use-package gnus
    :init
    (setq mail-user-agent 'gnus-user-agent)
    :config
    (setq gnus-select-method
          '(nntp "news.gwene.org"))
    (setq gnus-secondary-select-methods
          '((nnimap "gmail"
                    (nnimap-address "imap.gmail.com"))
            (nnimap "university"
                    (nnimap-address "outlook.office365.com"))
            (nnimap "mail.jamzattack.xyz")
            (nntp "news.eternal-september.org"
                  (nntp-authinfo-file "~/.authinfo.gpg"))))
    (defun gnus-group-set-up-imenu-please ()
      (setq imenu-generic-expression
            '(("Topic" "\\[ \\(.*?\\) -- [0-9]+ \\]" 1)
              ("Unread" "[1-9]+.*: \\(.*\\)" 1))))
    (add-hook 'gnus-group-mode-hook 'gnus-group-set-up-imenu-please)
    :bind
    ("C-z C-n" . gnus-unplugged)
    ("C-z n" . gnus))
#+end_src

**** Gnus-sum

Nicer summary & thread formatting.  Credit to [[https:protesilaos.com][Protesilaos Stavrou]]

#+begin_src emacs-lisp
  (use-package gnus-sum
    :defer t
    :custom
    (gnus-summary-line-format "%U%R%z %-16,16&user-date;  %4L:%-30,30f  %B%s\n")
    (gnus-summary-mode-line-format "%p")
    (gnus-sum-thread-tree-false-root "ââ¬> ")
    (gnus-sum-thread-tree-indent " ")
    (gnus-sum-thread-tree-leaf-with-other "ââ> ")
    (gnus-sum-thread-tree-root "")
    (gnus-sum-thread-tree-single-leaf "ââ> ")
    (gnus-sum-thread-tree-vertical "â"))
#+end_src

**** Gnus-msg

Gnus' library for sending messages.  [[help:gnus-posting-styles][gnus-posting-styles]] allows you to
adjust headers, signatures, etc. based on how you got to the
composition buffer.  All messages composed from my university mailbox
will be sent from my university address.  Very nice!

[[info:gnus#Posting Styles][Posting Styles in the gnus manual]]

#+begin_src emacs-lisp
  (use-package gnus-msg
    :defer t
    :custom
    (gnus-posting-styles
     '(("nnimap\\+university:.*"
        (From "Jamie Beardslee <beardsjami@myvuw.ac.nz>")
        (signature "Jamie Beardslee (300484191)"))
       ("nnimap\\+mail\\.jamzattack\\.xyz:.*"
        (From "Jamie Beardslee <jdb@jamzattack.xyz>")))))
#+end_src

**** Gnus-art

Article stuff.  Gnus tries to use the =smiley= library to convert
emoticons into images -- I turned it off becaus it looks terrible.

I also want some buttons to show signature status and alternative MIME
types, which is achieved with [[help:gnus-buttonized-mime-types][gnus-buttonized-mime-types]].

#+begin_src emacs-lisp
  (use-package gnus-art
    :defer t
    :custom
    (gnus-treat-display-smileys nil)
    (gnus-buttonized-mime-types
     '("multipart/signed" "multipart/alternative")))
#+end_src

**** Gnus-topic

Gnus can sort your groups by topic, which I enable in
[[help:gnus-group-mode-hook][gnus-group-mode-hook]].

It shows titles for empty topics by default, which I find to get in
the way.  I set the variable [[help:gnus-topic-display-empty-topics][gnus-topic-display-empty-topics]] to
disable this.  Default behaviour can be restored with =T H=.

#+begin_src emacs-lisp
  (use-package gnus-topic
    :defer t
    :custom
    (gnus-topic-display-empty-topics nil)
    :hook
    (gnus-group-mode . gnus-topic-mode))
#+end_src

**** Gnus-start

Just getting rid of a couple of extra files in $HOME.

- Gnus by default creates =~/.newsrc= in a format compatible with other
  newsreaders, but I don't use any so it's just an extra line in my
  ls.
- Move the /dribble/ (i.e. auto-save) files to =~/.cache=.

#+begin_src emacs-lisp
  (use-package gnus-start
    :defer t
    :custom
    (gnus-save-newsrc-file nil)
    (gnus-dribble-directory "~/.cache/"))
#+end_src

*** Sendmail

Sending mail.  I use [[https://marlam.de/msmtp/][msmtp]] to send mail because it works well with
multiple smtp servers.  I tried using [[info:smtpmail#Top][smtpmail]] but couldn't get it to
switch between the two easily.

I set it up to use the from header to determine how to send mail.

#+begin_src emacs-lisp
  (use-package sendmail
    :defer t
    :config
    (setq send-mail-function 'sendmail-send-it
          sendmail-program (or "msmtp"
                               "sendmail")
          mail-envelope-from 'header))
#+end_src

*** Message

The mode for editing messages.  I bind =C-c C-q= to a function that
either fills or unfills the message, and =C-c $= to check spelling.

#+begin_src emacs-lisp
  (use-package message
    :config
    (defun fill-message-please (&optional unfill)
      "Fill the whole message.

    With prefix arg UNFILL, unfill the message (i.e. paragraphs will
    all be on one line)"
      (interactive "P")
      (let ((fill-column (if unfill
                             (point-max)
                           fill-column)))
        (message-fill-yanked-message)))
    <<my-gnus-add-gcc-header>>
    :hook
    (message-send . my-gnus-add-gcc-header)
    :bind
    (:map message-mode-map
          ("C-c C-q" . fill-message-please)
          ("C-c $" . ispell-message)))
#+end_src

**** Archive mail from jamzattack.xyz

I can't figure out how to make my postfix server copy messages to
"Sent", so I do it with gnus.

#+name: my-gnus-add-gcc-header
#+begin_src emacs-lisp :tangle no
  (defun my-gnus-add-gcc-header ()
    "If message is from anybody@jamzattack.xyz, archive it via IMAP.
  This will also archive it in the default nnfolder+archive group."
    (interactive)
    (let ((new-gcc
           (format-time-string
            "nnfolder+archive:sent.%Y-%m, nnimap+mail.jamzattack.xyz:Sent")))
      (save-excursion
        (save-restriction
          (goto-char (point-min))
          (ignore-errors
            (when (re-search-forward "^From: \\(.*\\)jamzattack.xyz>?")
              (message-replace-header "Gcc" new-gcc)))))))
#+end_src

*** MIME

Stuff to do with MIME

**** mm-decode

The library responsible for decoding mime parts.  I prefer reading
text/plain, so discourage the other common alternatives.  I also want
to verify messages that have a signature, so I set [[help:mm-verify-option][mm-verify-option]].

#+begin_src emacs-lisp
  (use-package mm-decode
    :defer t
    :custom
    (mm-discouraged-alternatives
     '("text/html" "text/richtext"))
    (mm-verify-option 'known))
#+end_src

**** mml-sec

Yay for encryption.  I set up messages to encrypt to myself as well as
the recipient, and sign with the sender.

#+begin_src emacs-lisp
  (use-package mml-sec
    :defer t
    :custom
    (mml-secure-openpgp-encrypt-to-self t)
    (mml-secure-openpgp-sign-with-sender t))
#+end_src

** Typing

*** Input methods

#+begin_src emacs-lisp
  (use-package quail
    :defer t
    :config
    <<dvorak-keyboard-layout>>
    <<maori-input-method>>
    <<hangul-input-method>>
    )
#+end_src

**** Dvorak keyboard layout

Define a dvorak keyboard layout and enable it.

Quail keyboard layouts are laid out in six 30-column blocks.  The
first and last are above and below the alphanumeric keys.  Each key is
represented by a pair of its non-shifted and shifted variants i.e. =aA=
for the =a= key.

This allows me to use another input method's physical layout rather
than just the keys themselves.

In the =korean-hangul= input method though, characters' positions are
laid out according to the physical position, so I want that to be
taken into account.  In other words, I want to use the "qwerty k"
rather than the "dvorak k".

| Qwerty | Dvorak | Hangul |
|--------+--------+--------|
| k      | t      | ã     |
| r      | p      | ã±     |

Unfortunately, whether a keyboard layout actually uses this system is
totally random.  See the examples in the following table, where a
"layout dependent" input method means that it uses the keyboard
translation according to [[help:quail-keyboard-layout][quail-keyboard-layout]].

| Layout            | Layout dependent? | Should be? |
|-------------------+-------------------+------------|
| cyrillic-translit | t                 | nil        |
| programmer-dvorak | nil               | t          |
| korean-hangul     | nil               | t          |
| japanese          | nil               | nil        |

Because of this mess, I also define the function
[[help:toggle-quail-keyboard-layout][toggle-quail-keyboard-layout]], which switches between the two and is
bound to =s-\=

#+name: dvorak-keyboard-layout
#+begin_src emacs-lisp :tangle no
  (push
   (cons "dvorak"
         (concat
          "                              "
          "`~1!2@3#4$5%6^7&8*9(0)[{]}    "   ; numbers
          "  '\",<.>pPyYfFgGcCrRlL/?=+\\|  " ; qwerty
          "  aAoOeEuUiIdDhHtTnNsS-_      "   ; asdf
          "  ;:qQjJkKxXbBmMwWvVzZ        "   ; zxcv
          "                              "))
   quail-keyboard-layout-alist)

  (defun toggle-quail-keyboard-layout ()
    "Toggle the keyboard layout between dvorak and qwerty.

  This sets `quail-keyboard-layout-type' to the opposite of what is
  currently selected."
    (interactive)
    (if (string-equal quail-keyboard-layout-type "dvorak")
        (quail-set-keyboard-layout "standard")
      (quail-set-keyboard-layout "dvorak"))
    (message "Switched to layout: %s"
             (propertize quail-keyboard-layout-type
                         'face 'bold)))

  (bind-key "s-\\" 'toggle-quail-keyboard-layout)
#+end_src

**** MÄori

My own input method for MÄori.  It provides prefix and postfix
variants.

- Postfix:
| aa  | Ä  |
| a-  | Ä  |
| aaa | aa |
| a-- | a- |

- Prefix:
| aa  | Ä  |
| -a  | Ä  |
| aaa | aa |
| --a | -a |

Located [[file:lisp/input/maori-input-method.el][here]].

#+name: maori-input-method
#+begin_src emacs-lisp :tangle no
  (use-package maori-input-method
    :load-path "lisp/input")
#+end_src

**** Hangul

An adjustment to the hangul input method that uses
[[help:quail-keyboard-translate][quail-keyboard-translate]] to
determine the character, rather than assuming the standard layout.

For more information, see [[*Dvorak keyboard layout][this section]] and [[https://blog.jamzattack.xyz/emacs-hangul-input.html][my blog post about the
subject]].

#+name: hangul-input-method
#+begin_src emacs-lisp :tangle no
  (with-eval-after-load 'hangul
    (defun hangul2-input-method (key)
      "2-Bulsik input method."
      (setq key (quail-keyboard-translate key))
      (if (or buffer-read-only (not (alphabetp key)))
          (list key)
        (quail-setup-overlays nil)
        (let ((input-method-function nil)
              (echo-keystrokes 0)
              (help-char nil))
          (setq hangul-queue (make-vector 6 0))
          (hangul2-input-method-internal key)
          (unwind-protect
              (catch 'exit-input-loop
                (while t
                  (let* ((seq (read-key-sequence nil))
                         (cmd (lookup-key hangul-im-keymap seq))
                         key)
                    (cond
                     ((and (stringp seq)
                           (= 1 (length seq))
                           (setq key (quail-keyboard-translate (aref seq 0)))
                           (alphabetp key))
                      (hangul2-input-method-internal key))
                     ((commandp cmd)
                      (call-interactively cmd))
                     (t
                      (setq unread-command-events
                            (nconc (listify-key-sequence seq)
                                   unread-command-events))
                      (throw 'exit-input-loop nil))))))
            (quail-delete-overlays))))))
#+end_src

**** Fixing various input methods

As said [[*Dvorak keyboard layout][above]], some input methods don't work the way they should with
a custom [[help:quail-keyboard-layout][quail-keyboard-layout]].

The variable [[help:quail-package-alist][quail-package-alist]] is an alist of the following values:
| Index | Description                 |
|-------+-----------------------------|
|     0 | NAME                        |
|     1 | TITLE                       |
|     2 | QUAIL-MAP                   |
|     3 | GUIDANCE                    |
|     4 | DOCSTRING                   |
|     5 | TRANSLATION-KEYS            |
|     6 | FORGET-LAST-SELECTION       |
|     7 | DETERMINISTIC               |
|     8 | KBD-TRANSLATE               |
|     9 | SHOW-LAYOUT                 |
|    10 | DECODE-MAP                  |
|    11 | MAXIMUM-SHORTEST            |
|    12 | OVERLAY-PLIST               |
|    13 | UPDATE-TRANSLATION-FUNCTION |
|    14 | CONVERSION-KEYS             |
|    15 | SIMPLE                      |

The elements I'm mostly interested in are 8 (=KBD-TRANSLATE=) and 9
(=SHOW-LAYOUT=).

#+begin_src emacs-lisp
  (with-eval-after-load "quail/cyrillic"	; no kbd-translate
    (setf (nth 8 (assoc "cyrillic-translit" quail-package-alist)) nil
          (nth 9 (assoc "cyrillic-translit" quail-package-alist)) t))

  (with-eval-after-load "quail/programmer-dvorak"	; kbd-translate
    (setf (nth 8 (assoc "programmer-dvorak" quail-package-alist)) t
          (nth 9 (assoc "programmer-dvorak" quail-package-alist)) t))
#+end_src

*** Abbrevs

#+begin_src emacs-lisp
  (use-package abbrev
    :hook
    (text-mode . abbrev-mode)
    :delight
    :config
    (setq save-abbrevs nil)
    <<text-mode-abbrevs>>
    )
#+end_src

**** My text-mode abbrevs

#+name: text-mode-abbrevs
#+begin_src emacs-lisp :tangle no
  (use-package text-mode-abbrevs
    :load-path "lisp/abbrev")
#+end_src

** Printing

Library for printing things as postscript.

The =header= variables are related to the automatically generated header
that shows the buffer name, file name, date, and page number.  I end
up disabling this feature by setting [[help:ps-print-header][ps-print-header]] to =nil=, but
nonetheless want it to look nicer in case I want to print buffer that
needs pages numbers.  I can do this with the function
[[help:please-print-buffer-with-header][please-print-buffer-with-header]] defined [[please-print-buffer][here]].

The [[https://en.wikipedia.org/wiki/N-up][n-up]] variables are for printing multiple pages on a single sheet
of paper.  I use this via [[help:please-print-buffer-side-by-side][please-print-buffer-side-by-side]] also
defined [[please-print-buffer][here]].  I set [[help:ps-n-up-margin][ps-n-up-margin]] to 7, which is roughly 2.5mm.
This allows for two 70-character wide pages to be printed side by
side.

#+begin_src emacs-lisp
  (use-package ps-print
    :defer t
    :init
    <<please-print-buffer>>
    :config
    (setq ps-print-header nil
          ps-print-header-frame nil
          ps-header-lines 1
          ps-header-font-size ps-font-size
          ps-header-title-font-size ps-font-size
          ps-n-up-border-p nil
          ps-left-margin (/ (* 72 1.0) 2.54) ; 1 cm
          ps-right-margin (/ (* 72 1.0) 2.54) ; 1 cm
          ps-n-up-margin (/ (* 72 0.5) 2.54))) ; 5 mm
#+end_src

*** Printing functions

[[help:please-print-buffer][please-print-buffer]] is a big printing function that asks a few
[[help:y-or-n-p][y-or-n-p]]s to determine some commonly used settings.

A couple of separate functions for invidual options are also defined:
[[help:please-print-buffer-with-header][please-print-buffer-with-header]] and [[help:please-print-buffer-side-by-side][please-print-buffer-side-by-side]].

I autoload [[help:ps-print-preprint][ps-print-preprint]] rather than using [[help:require][require]], as this goes
in the =:init= section.

#+name: please-print-buffer
#+begin_src emacs-lisp :tangle no
  (autoload 'ps-print-preprint "ps-print")

  (defun please-print-buffer (&optional file color header side-by-side)
    "Print the current BUFFER.

  FILE is a filename to save the generated postscript in.  If this
  is provided, it will NOT be sent to the printer.

  The arguments COLOR and SIDE-BY-SIDE are straightforward -- they
  will be determined via `y-or-n-p'.

  HEADER works weirdly interactively -- I don't usually want the
  header printed so the `y-or-n-p' asks whether to remove it."
    (interactive
     (list
      ;; `ps-print-preprint' needs a list or number argument
      (ps-print-preprint (when (y-or-n-p "Save to file? ") 1))
      (y-or-n-p "Color? ")
      (not (y-or-n-p "Remove header? "))
      (y-or-n-p "Side by side? ")))
    (let* ((ps-font-size
            (if side-by-side
                '(10 . 12)
              ps-font-size))
           (ps-n-up-printing
            (if side-by-side
                2
              1))
           (ps-print-header header)
           (ps-print-color-p (if color
                                 t
                               'black-white)))
      (ps-print-buffer-with-faces file)))

  (defun please-print-buffer-side-by-side (file &optional color)
    "Print the current buffer, split into two subpages.

  This calls `ps-print-buffer-with-faces' with the variable
  `ps-n-up-printing' set to 2."
    (interactive
     (list (ps-print-preprint current-prefix-arg)
           (y-or-n-p "Color? ")))
    (please-print-buffer file color ps-print-header t))

  (defun please-print-buffer-with-header (file &optional color)
    "Print the current buffer with a header.

  This calls `ps-print-buffer-with-faces' with the variable
  `ps-print-header' set to t."
    (interactive
     (list (ps-print-preprint current-prefix-arg)
           (y-or-n-p "Color? ")))
    (please-print-buffer file color t))
#+end_src

* Local packages

Not necessarily /my/ packages, but packages that are in the [[file:lisp/][lisp]]
directory.

** Internet

A selection of packages to facilitate searching and browsing the web
within Emacs.

*** Library-genesis

My custom package for searching library genesis.  I bind =C-z l= to a
search.

Located [[file:lisp/library-genesis/library-genesis.el][here]].

#+begin_src emacs-lisp
  (use-package library-genesis
    :load-path "lisp/library-genesis"
    :bind
    ("C-z l" . library-genesis-search))
#+end_src

*** Reddit-browse

This is a very minimal package to ease the use of reddit within eww.
It uses the old reddit mobile site, which works well with eww.

Located [[file:lisp/reddit-browse/reddit-browse.el][here]].

#+begin_src emacs-lisp
  (use-package reddit-browse
    :load-path "lisp/reddit-browse"
    :custom
    (reddit-subreddit-list '("emacs" "lisp" "lispmemes"
                             "vxjunkies" "linux" "nethack"
                             "cello" "throwers"))
    :bind
    ("C-z r" . reddit-goto-subreddit))
#+end_src

** Toggle touchpad

A simple package I wrote to toggle the touchpad/trackpoint on my
ThinkPad

Located [[file:lisp/toggle-touchpad/toggle-touchpad.el][here]].

#+begin_src emacs-lisp
  (use-package toggle-touchpad
    :load-path "lisp/toggle-touchpad"
    :bind
    ("<XF86TouchpadToggle>" . toggle-touchpad)
    ("C-z \\" . toggle-touchpad))
#+end_src

** Arch Linux settings

This file just adds a few [[help:auto-mode-alist][auto-mode-alist]] entries for systemd and
pacman files.

Located [[file:lisp/arch-linux-settings/arch-linux-settings.el][here]].

#+begin_src emacs-lisp
  (use-package arch-linux-settings
    :load-path "lisp/arch-linux-settings")
#+end_src

** Custom EXWM config

My custom settings for EXWM - not much different from the
[[help:exwm-config-default][exwm-config-default]], but doesn't get in my way as much.  It provides
the function [[help:custom-exwm-config][custom-exwm-config]] which is run when exwm starts.

Note: this doesn't actually start EXWM, so this needs to be done in
your [[file:~/.xinitrc][xinitrc]].

Located [[file:lisp/exwm/custom-exwm-config.el][here]].

#+begin_src emacs-lisp
  (use-package custom-exwm-config
    :load-path "lisp/exwm"
    :commands custom-exwm-config
    :hook
    (exwm-init . custom-exwm-config))
#+end_src

** Miscellaneous functions

A number of functions that don't necessarily have a proper home.  Bind
=C-c p= to open the pdf output of a typesetting program, and =C-h M-a= to
run the external "apropos" command (not to be confused with Elisp
apropos).

Located [[file:lisp/my-misc-defuns/my-misc-defuns.el][here]].

#+begin_src emacs-lisp
  (use-package my-misc-defuns
    :load-path "lisp/my-misc-defuns"
    :bind
    ("C-M-\\" . indent-region-or-defun-please)
    ("C-h M-a" . system-apropos)
    ("C-c p" . open-pdf-of-current-file))
#+end_src

** Custom Helm bookmarks

This package defines a macro to create new bookmark sources, and adds
a few.

Located [[file:lisp/helm/custom-helm-bookmark.el][here]].

#+begin_src emacs-lisp
  (use-package custom-helm-bookmark
    :load-path "lisp/helm"
    :after helm
    :custom
    (helm-bookmark-default-filtered-sources
     '(helm-source-bookmark-university
       helm-source-bookmark-gnus
       helm-source-bookmark-config
       helm-source-bookmark-org-misc
       helm-source-bookmark-elisp
       helm-source-bookmark-downloads
       helm-source-bookmark-magit
       helm-source-bookmark-dired
       helm-source-bookmark-info
       helm-source-bookmark-man
       helm-source-bookmark-other
       helm-source-bookmark-set)))
#+end_src

** Minibuffer hacks

A very tiny package, just defining two functions to make the
minibuffer a bit nicer.

[[help:increase-minibuffer-size-please][increase-minibuffer-size-please]] increases the font size a bit, I add
it to [[help:minibuffer-setup-hook][minibuffer-setup-hook]].

[[help:exit-minibuffer-other-window][exit-minibuffer-other-window]] exits the minibuffer in another window.
This requires Emacs 28, as it uses [[help:other-window-prefix][other-window-prefix]].  I bind it to
=M-RET=.  e.g. =M-x eww emacs M-RET= will open [[help:eww][eww]] in another window.

#+begin_src emacs-lisp
  (use-package minibuffer-hacks
    :load-path "lisp/minibuffer-hacks"
    :bind
    (:map minibuffer-local-map
          ("M-RET" . exit-minibuffer-other-window))
    :hook
    (minibuffer-setup . increase-minibuffer-size-please))
#+end_src

** Custom bitmaps

The default fringe bitmaps aren't that pretty, so I define a few of my
own.

Currently, it's only:
- left/right arrows (truncated lines)
- left/right curly arrows (wrapped lines)

#+begin_src emacs-lisp
  (use-package my-bitmaps
    :load-path "lisp/bitmaps"
    :hook
    (server-after-make-frame . my-bitmaps-enable)
    (window-setup . my-bitmaps-enable))
#+end_src

* Third party packages

This is where the packages installed with [[https://github.com/raxod502/straight.el][straight.el]] are located.
All of these use the =:straight= keyword, so that they are downloaded if
they aren't already.

** epkg

Since I don't use the built-in =package= library, [[https://emacsmirror.net/][epkg]] is a nice
replacement for the UI (paired with [[*Straight][straight]] for installing).  It
provides functions to describe, list, search by author.

One of the biggest advantages is that is shows way more information in
the *describe* buffer, including:
- dependencies
- reverse dependencies
- downloads
- github stars
- when last updated

It also comes with an [[info:epkg#Top][info manual]], yippee!

#+begin_src emacs-lisp
  (use-package epkg
    :straight t
    :config
    <<epkg-straight>>
    :bind
    ([remap describe-package] . epkg-describe-package)
    ([remap finder-by-keyword] . epkg-list-matching-packages))
#+end_src

*** "Install with straight" button

Advise [[help:epkg-describe-package][epkg-describe-package]] to add a button for installation with
straight.

#+name: epkg-straight
#+begin_src emacs-lisp :tangle no
  (defun add-straight-button-to-epkg-describe (pkg &rest _ignored)
    (when (member pkg (straight-recipes-list))
      (let ((inhibit-read-only t))
        (with-current-buffer (help-buffer)
          (goto-char (point-min))
          (forward-line 1)
          (insert "\n")
          (insert-button (format "Install %s with straight"
                                 (propertize pkg 'face '(:inherit bold)))
                         'action `(lambda (&rest _ignored)
                                    (straight-use-package ',(intern pkg))))
          (insert "\n")))))

  (advice-add 'epkg-describe-package :after #'add-straight-button-to-epkg-describe)
#+end_src

** HELM

Rebind a few keys in order to make use of Helm's features.  Stuff like
[[help:find-file][find-file]] and [[help:switch-to-buffer][switch-to-buffer]].  Also remap =C-x k= to kill-this-buffer,
because I use helm-mini to kill other buffers.

I also bind =M-C-y= to [[help:helm-show-kill-ring][helm-show-kill-ring]].  I tried to use this to
replace [[help:yank-pop][yank-pop]] but the latter is too engrained in my fingers.

#+begin_src emacs-lisp
  (use-package helm
    :straight t
    :custom
    (helm-completion-style 'emacs)
    (helm-describe-variable-function 'helpful-variable)
    (helm-describe-function-function 'helpful-callable)
    (helm-buffer-max-length 24)
    (helm-split-window-preferred-function
     #'helm-split-window-please)
    (helm-ff-keep-cached-candidates nil)
    (helm-external-programs-associations
     '(("midi" . "timidity")
       ("png" . "sxiv")
       ("jpg" . "sxiv")
       ("gif" . "mpv -L")
       ("mp4" . "mpv")
       ("mkv" . "mpv")
       ("avi" . "mpv")
       ("webm" . "mpv")
       ("ps" . "zathura")
       ("pdf" . "zathura")))
    (helm-ff-cache-mode-lighter-sleep "")
    (helm-ff-cache-mode-lighter-updating "")
    :init
    <<kill-this-buffer-please>>
    :config
    <<helm-split-window-please>>
    <<un-helmify>>
    (require 'helm-config)
    (delight '((helm-mode "")))
    (helm-mode t)
    :bind
    ([remap execute-extended-command] . helm-M-x)
    ("<menu><menu>" . helm-M-x)
    ("M-o" . helm-occur)
    ("s-b" . helm-mini)
    ([remap switch-to-buffer] . helm-mini)
    ("C-x k" . kill-this-buffer-please)
    ([remap find-file] . helm-find-files)
    ([remap bookmark-jump] . helm-filtered-bookmarks)
    ("M-C-y" . helm-show-kill-ring)
    (:map helm-map
          ("C-x C-t" . helm-toggle-resplit-and-swap-windows)
          ("C-t" . transpose-chars)
          ("C-h c" . describe-key-briefly)))
#+end_src

*** un-helmifying some commands

Helm provides the variable [[help:helm-completing-read-handlers-alist][helm-completing-read-handlers-alist]] to
determine which commands use helm for completing-read.

I disable helm for [[info:emacs#Highlight Interactively][hi-lock]] functions, as they read a face name which
is pretty slow, and [[help:insert-char][insert-char]].

#+name: un-helmify
#+begin_src emacs-lisp :tangle no
  (with-eval-after-load 'helm-mode
    (dolist (f '(highlight-symbol-at-point
                 highlight-regexp
                 highlight-lines-matching-regexp
                 highlight-phrase
                 insert-char))
      (add-to-list 'helm-completing-read-handlers-alist
                   (list f))))
#+end_src

*** Functions

**** Kill buffer

I rebind =C-x k= to kill the current buffer, because [[help:helm-mini][helm-mini]] is so
useful.  If buffer is in the list [[help:buffers-to-bury][buffers-to-bury]], bury it instead of
killing.

#+name: kill-this-buffer-please
#+begin_src emacs-lisp :tangle no
  (defvar buffers-to-bury '("*scratch*" "#emacs" "*Messages*")
    "List of buffers to bury instead of kill with the function
  `kill-this-buffer-please'")

  (defun kill-this-buffer-please ()
    "Actually kill this buffer, unlike `kill-this-buffer' which
  sometimes doesn't work."
    (interactive)
    (if (member (buffer-name) buffers-to-bury)
        (bury-buffer)
      (kill-buffer (current-buffer))))
#+end_src

**** Split window

The way Helm splits windows can get in the way a bit.  This more
predictable function selects the largest non-exwm window.

#+name: helm-split-window-please
#+begin_src emacs-lisp :tangle no
  (defun helm-split-window-please (window)
    "If the frame only has one window, split it.  Otherwise, select
  the largest non-exwm window."
    (if (one-window-p t)
        (split-window (selected-window) nil
                      (if (> (window-pixel-width) (window-pixel-height))
                          'right
                        'below))
      (select-window
       ;; Reworking of `get-largest-window', doesn't choose an exwm
       ;; window.
       (let ((best-size 0)
             best-window size)
         (dolist (window (window-list-1 nil 'nomini))
           (when (and (not (window-dedicated-p window))
                      (not (eq window (selected-window)))
                      (not (equal
                            (buffer-local-value
                             'major-mode (window-buffer window))
                            'exwm-mode)))
             (setq size (* (window-pixel-height window)
                           (window-pixel-width window)))
             (when (> size best-size)
               (setq best-size size)
               (setq best-window window))))
         best-window))))
#+end_src

*** Helm Imenu

Helm's interface to imenu.  It shows more information than [[help:imenu][imenu]] does,
and also provides a way to access an imenu for multiple buffers.

Note: I use =:bind*= because LilyPond-mode tries to bind =C-c i=.

#+begin_src emacs-lisp
  (use-package helm-imenu
    :straight helm
    :defer t
    :bind*
    ("C-c i" . helm-imenu)
    ("C-c I" . helm-imenu-in-all-buffers))
#+end_src

*** Helm man

Remap =C-h C-m= to [[help:helm-man-woman][helm-man-woman]], a Helm interface for selecting
manpages.

#+begin_src emacs-lisp
  (use-package helm-man
    :defer t
    :straight helm
    :custom
    (man-width 80)
    :bind
    (:map help-map
          ("C-m" . helm-man-woman)))
#+end_src

*** Helm system packages

Provides an abstraction layer for viewing and installing system
packages.

#+begin_src emacs-lisp
  (use-package helm-system-packages
    :straight t
    :bind
    (:map help-map
          ("C-p" . helm-system-packages)))
#+end_src

*** Helm eww

Some Helm functions for eww.  I replace all the default functions with
the Helm alternatives [[*EWW][here]].

#+begin_src emacs-lisp
  (use-package helm-eww
    :straight t
    :bind
    ("C-x r e" . helm-eww-bookmarks))
#+end_src

*** Helm org

=C-c M-o= in org-mode runs the function
[[help:helm-org-in-buffer-headings][helm-org-in-buffer-headings]].
Similar to [[help:occur][occur]], but only shows headings.

#+begin_src emacs-lisp
  (use-package helm-org
    :straight t
    :after org
    :bind
    (:map org-mode-map
          ("C-c M-o" . helm-org-in-buffer-headings)))
#+end_src

*** Helm color

The default action of [[help:helm-colors][helm-colors]] is [[help:customize-face][customize-face]].  I rarely find it
more convenient than [[help:describe-face][describe-face]], so I replace it.

Note: this comes with [[*HELM][Helm]].

#+begin_src emacs-lisp
  (use-package helm-color
    :defer t
    :config
    (setf (alist-get 'action helm-source-customize-face)
          '(("Describe". (lambda (line)
                           (describe-face
                            (intern (car (split-string line))))))
            ("Customize". (lambda (line)
                            (customize-face
                             (intern (car (split-string line))))))
            ("Copy name" . (lambda (line)
                             (kill-new (car (split-string line " " t))))))))
#+end_src

*** Helm epa mode

Since quite recently ([2020-08-15 Sat 07:22], commit =caf78b98=) helm
has included an interface for [[info:epa#Top][epa]].  I enable it, of course, not only
because Helm makes for a convenient completing-read, but because the
stock key/recipient selection _sucks_.

#+begin_src emacs-lisp
  (use-package helm-misc
    :after helm epa
    :config
    (helm-epa-mode))
#+end_src

** Helpful

Helpful gives a whole lot more information than =describe-*=.  I also
bind =C-h SPC= to helpful-at-point, just to save a keypress here and
there.  The =:straight= recipe uses my fork, which doesn't depend on
=f.el=.  (I know it's minor, but I'd rather not load the extra
library).

#+begin_src emacs-lisp
  (use-package helpful
    :straight
    (helpful :type git
             :flavor melpa
             :host gitlab
             :repo "jamzattack/helpful"
             :branch "no-f")
    :config
    <<helpful-edit-source-temporarily>>
    <<helpful-copy-to-kill-ring>>
    (with-eval-after-load 'ol
      (defun org-link--open-help (str)
        "Open a \"help\" type link.
  PATH is a symbol name, as a string."
        (helpful-symbol (intern str))))
    (with-eval-after-load 'erc-button
      (defun erc-button-describe-symbol (str)
        "Describe the symbol named STR.
  This uses the `helpful' library instead of `describe-*'"
        (let ((symbol (intern-soft str)))
          (if symbol
              (helpful-symbol symbol)
            (apropos str)))))
    :bind
    (:map help-map
          ("f" . helpful-callable)
          ("v" . helpful-variable)
          ("o" . helpful-symbol)
          ("k" . helpful-key)
          ("SPC" . helpful-at-point))
    (:map helpful-mode-map
          ("e" . helpful-edit-source-temporarily)
          ("w" . helpful-copy-to-kill-ring)))
#+end_src

*** Edit source

A function that opens up a new buffer with the source shown in the
current =helpful= buffer.

This now works with both Elisp and C source code.

#+name: helpful-edit-source-temporarily
#+begin_src emacs-lisp :tangle no
  (defun helpful-edit-source-temporarily ()
    "Edit the source shown in the current helpful buffer.

  This pops open a buffer with only the symbol's source, rather
  than taking you to its file.

  Works with both elisp and C source code."
    (interactive)
    (unless (derived-mode-p 'helpful-mode)
      (user-error "Not in a helpful buffer"))
    (save-excursion
      (let* ((buffer
              (get-buffer-create
               (format "*%s (source)*"
                       helpful--sym)))
             (min (progn
                    (goto-char (point-min))
                    (or (re-search-forward "^Source Code$" nil t)
                        (error "No source available"))
                    (forward-line 1)
                    (point)))
             (max (progn
                    (goto-char min)
                    (end-of-defun)
                    (point)))
             (primitive-p
              (helpful--primitive-p helpful--sym helpful--callable-p)))
        (copy-to-buffer buffer
                        min
                        max)
        (pop-to-buffer buffer)
        (if primitive-p
            (c-mode)
          (emacs-lisp-mode)))))
#+end_src

*** Save symbol to kill ring

#+name: helpful-copy-to-kill-ring
#+begin_src emacs-lisp :tangle no
  (defun helpful-copy-to-kill-ring (buffer)
    "Copy the callable or variable of BUFFER to the kill ring.

  Called interactively, BUFFER is the current buffer or, with
  prefix arg, read from the minibuffer."
    (interactive (list
                  (if current-prefix-arg
                      (read-buffer "Copy symbol from buffer: "
                                   (current-buffer)
                                   t
                                   (lambda (name)
                                     (string-match
                                      "^\\*helpful"
                                      name)))
                    (current-buffer))))
    (with-current-buffer buffer
      (unless (eq major-mode 'helpful-mode)
        (user-error "%s is not a helpful buffer" (buffer-name buffer)))
      (kill-new (symbol-name helpful--sym))
      (message "\"%s\" saved to kill ring." helpful--sym)))
#+end_src

** Major Modes

*** Nov.el - epub in emacs

Read epub files in Emacs.  I set this up as the default mode for
epubs, and set the default width to 80 columns.

#+begin_src emacs-lisp
  (use-package nov
    :straight t
    :custom
    (nov-text-width 80)
    (nov-variable-pitch nil)
    :mode ("\\.epub\\'" . nov-mode)
    :bind
    (:map nov-mode-map
          ([remap set-fill-column] . nov-set-width))
    :config
    <<nov-set-text-width>>
    )
#+end_src

**** Set text width in nov buffer

#+begin_src emacs-lisp :tangle no
  (defun nov-set-width (width)
    "Set the nov rendering width to WIDTH.

  If prefix arg is a number, use it.  Otherwise, read number from
  the minibuffer."
    (interactive (list
                  (if (numberp current-prefix-arg)
                      current-prefix-arg
                    (read-number "Set width: "
                                 (- (window-width) 5)))))
    (when (derived-mode-p 'nov-mode)
      (setq nov-text-width width)
      (nov-render-document)))
#+end_src

*** PDF-tools

Majorly increases performance when viewing pdfs within Emacs, and
provides some note-taking facilities.

#+begin_src emacs-lisp
  (use-package pdf-tools
    :straight t
    :magic ("%PDF" . pdf-view-mode)
    :custom
    (pdf-links-browse-uri-function #'pdf-links-open-please)
    :hook
    (pdf-view-mode . auto-revert-mode)
    :config
    <<pdf-links-open-please>>
    (pdf-tools-install))
#+end_src

**** Custom link handler

Awkward hacky workaround to get LilyPond's links to open properly.

#+name: pdf-links-open-please
#+begin_src emacs-lisp :tangle no
  (defun pdf-links-open-please (uri)
    "Open \"textedit://\" links via `find-file', and jump to the
  right point.  I use this because lilypond output contains such
  links."
    (cond ((string-match "textedit://" uri)
           (let* ((path
                   ;; get rid of textedit://
                   (replace-regexp-in-string
                    "^textedit://"
                    ""
                    uri))
                  (split
                   (split-string path ":"))
                  (file
                   (url-unhex-string
                    (apply #'concat
                           (butlast split 3))))
                  (extras
                   (reverse
                    (cdr split)))
                  (line
                   (string-to-number
                    (caddr extras)))
                  (column
                   (string-to-number
                    (car extras)))
                  (buffer
                   (find-file-noselect file)))
             (pop-to-buffer buffer)
             (goto-char (point-min))
             (forward-line (1- line))
             (move-to-column column)))
          (t
           (pdf-links-browse-uri-default uri))))
#+end_src

*** LilyPond-mode

I mirror the lilypond-mode source on my git server, in case I need to
use it on a system where lilypond isn't installed.

Located [[https://git.jamzattack.xyz/lilypond-mode][here]].

#+begin_src emacs-lisp
  (use-package lilypond-mode
    :straight
    (lilypond-mode :type git
                   :repo "git@jamzattack.xyz:lilypond-mode.git")
    :delight
    (LilyPond-mode "ly" :major)
    :init
    (defalias 'lilypond-mode 'LilyPond-mode)
    <<custom-lilypond-setup>>
    :mode ("\\.ly\\'" . LilyPond-mode)
    :hook (LilyPond-mode . custom-lilypond-setup))
#+end_src

**** Custom lilypond setup

A few miscellaneous things to add to [[help:LilyPond-mode-hook][LilyPond-mode-hook]].

- Loads local variables ([[help:LilyPond-mode][LilyPond-mode]] missed this somehow)
- Set [[help:compile-command][compile-command]] if there's no Makefile or local variable
- Sets the [[help:comment-column][comment-column]] to 0
- Sets up imenu regexps to show:
  - Bar numbers
  - Page numbers
  - Movement numbers
  - TODOs
  - Definitions
- Turns on [[help:display-fill-column-indicator-mode][display-fill-column-indicator-mode]] if it's available
  (currently on master branch)

#+name: custom-lilypond-setup
#+begin_src emacs-lisp :tangle no
  (defun custom-lilypond-setup ()
    "Sets a bunch of things up for `LilyPond-mode'."
    (interactive)
    (hack-local-variables)
    (unless (or (file-exists-p "Makefile")
                (local-variable-p 'compile-command (current-buffer)))
      (setq-local compile-command
                  (format "lilypond \"%s\"" buffer-file-name)))
    (setq-local comment-column 0)
    (setq-local imenu-generic-expression
                '(("Bar" "^% bar \\([0-9]+\\)" 1)
                  ("Page" "^% PAGE \\([A-Z0-9]+\\)" 1)
                  ("Movement" "^% \\([Mm]o?ve?m?e?n?t\\) \\([A-Za-z0-9]+\\)" 2)
                  ("TODO" "^%?.*TODO[: ]?*\\(.*\\)" 1)
                  ("Variables" "^\\([a-zA-Z]+\\) *=" 1)))
    (when (fboundp 'display-fill-column-indicator-mode)
      (setq fill-column 80)
      (display-fill-column-indicator-mode)))
#+end_src

*** Markdown

A very featureful major mode for markdown files.  I only really use it
for looking at READMEs though, so I add view-mode to the hook.

#+begin_src emacs-lisp
  (use-package markdown-mode
    :straight t
    :mode "\\.md\\'"
    :hook (markdown-mode . view-mode))
#+end_src

*** GNU APL mode

I've been trying to learn a bit of APL recently, and [[help:gnu-apl-mode][gnu-apl-mode]] is
an excellent way to get into it.  It tries to use the super modifier
to insert special characters, but I use it for my own functions so I
set the prefix to ". ".

#+begin_src emacs-lisp
  (use-package gnu-apl-mode
    :straight t
    :mode
    "\\.apl'"
    :custom
    (gnu-apl-interactive-mode-map-prefix ". ")
    (gnu-apl-mode-map-prefix ". "))
#+end_src

** Programming

*** Geiser

Interact with scheme in a powerful and emacsy way.  I set the scheme
program name (which isn't actually a part of geiser) to whichever
scheme is installed, in order of preference.

#+begin_src emacs-lisp
  (use-package geiser
    :straight t
    :defer t
    :delight
    (scheme-mode "scm" :major)
    (geiser-repl-mode "SCM>" :major)
    (geiser-autodoc-mode)
    :hook
    (geiser-repl-mode . paredit-mode)
    :custom
    (scheme-program-name
     (or (executable-find "guile3.0")
         (executable-find "guile")
         (executable-find "chez")
         (executable-find "mit-scheme")
         "scheme"))
    (geiser-default-implementation 'guile)
    (geiser-repl-history-filename "~/.cache/geiser/history"))
#+end_src

*** SLIME

Interact with Common Lisp in a powerful and emacsy way.  I set the
default Lisp program, add some fancier stuff such as a nicer REPl, and
move the history file out of =$HOME=.

#+begin_src emacs-lisp
  (use-package slime
    :straight t
    :delight
    (lisp-mode "cl" :major)
    (slime-repl-mode "CL>" :major)
    (slime-mode)
    (slime-autodoc-mode)
    :init
    (autoload 'slime-switch-to-output-buffer "slime-repl")
    (defun disable-slime-completion ()
      (setq slime-completion-at-point-functions
            '(slime-simple-completion-at-point)))
    :hook (slime-connected . disable-slime-completion)
    :custom
    (inferior-lisp-program
     (or (executable-find "sbcl")
         (executable-find "ccl")
         (executable-find "clisp")
         "lisp"))
    (slime-contribs '(slime-fancy))
    (slime-repl-history-file "~/.cache/slime/history")
    (common-lisp-hyperspec-root
     (if (file-exists-p "/usr/share/doc/HyperSpec/")
         "file:///usr/share/doc/HyperSpec/"
       "http://clhs.lisp.se/"))
    (slime-auto-start 'ask)
    :bind
    (:map slime-mode-map
          ("C-c C-z" . slime-switch-to-output-buffer)))
#+end_src

*** Paredit

Efficient and clever editing commands for working with s-expressions.
Only fully enabled in Lisp modes, but I also define a few useful keys
globally.

- [ ] TODO replace all these hooks with [[help:lisp-data-mode-hook][lisp-data-mode]], added in 28.

#+begin_src emacs-lisp
  (use-package paredit
    :straight t
    :defer t
    :delight
    :bind
    ("M-\"" . paredit-meta-doublequote)
    ("M-(" . paredit-open-round)
    ("C-(" . paredit-backward-slurp-sexp)
    ("C-)" . paredit-forward-slurp-sexp)
    ("C-{" . paredit-backward-barf-sexp)
    ("C-}" . paredit-forward-barf-sexp)
    (:map paredit-mode-map
          ("M-R" . paredit-splice-sexp-killing-backward))
    :hook
    (emacs-lisp-mode . paredit-mode)
    (lisp-interaction-mode . paredit-mode)
    (ielm-mode . paredit-mode)
    (eval-expression-minibuffer-setup . paredit-mode)
    (lisp-mode . paredit-mode)
    (slime-repl-mode . paredit-mode)
    (scheme-mode . paredit-mode))
#+end_src

*** Elf-mode

Major mode for viewing ELF files (compiled binaries).  I don't use it
often, but it's nice to be able to see what a program does sometimes.

#+begin_src emacs-lisp
  (use-package elf-mode
    :straight t
    :magic ("ELF" . elf-mode))
#+end_src

*** Selime                                                             :mine:

This is my package to make Elisp evaluation and documentation lookup a
bit more like Slime.  It's often not necessary, but sometimes I find
myself using =C-c C-d C-f= to describe an Elisp function, etc.

Hosted [[https://git.jamzattack.xyz/selime][here]].

#+begin_src emacs-lisp
  (use-package selime
    :straight
    (selime :type git
            :flavor melpa
            :repo "git@jamzattack.xyz:selime.git")
    :hook (emacs-lisp-mode . selime-mode))
#+end_src

*** LilyPond auto-insert                                               :mine:

My own package to handle auto-insertions for LilyPond-mode.  I add it
to [[help:LilyPond-mode-hook][LilyPond-mode-hook]].

Hosted [[https://git.jamzattack.xyz/lilypond-auto-insert][here]].

#+begin_src emacs-lisp
  (use-package lilypond-auto-insert
    :straight
    (lilypond-auto-insert :type git
                          :flavor melpa
                          :repo "git@jamzattack.xyz:lilypond-auto-insert.git")
    :after lilypond-mode
    :custom
    (lilypond-auto-insert-language "english")
    :bind
    (:map LilyPond-mode-map
          ("C-c a" . lilypond-auto-insert)))
#+end_src

** Extra org packages

*** Github markdown

Export to markdown.

#+begin_src emacs-lisp
  (use-package ox-gfm
    :straight t
    :defer t)
#+end_src

*** Html export

Export to html.

#+begin_src emacs-lisp
  (use-package htmlize
    :straight t
    :defer t)
#+end_src

*** Org web tools

This package parses a web page and transforms it into beautiful
org-mode.  I use it in my package [[*Plumb][plumb]].

#+begin_src emacs-lisp
  (use-package org-web-tools
    :straight t
    :defer t)
#+end_src

** EXWM - Emacs X Window Manager

Manipulate X windows as Emacs buffers.  As mentioned [[*Custom EXWM config][earlier]], you need
to enable exwm (via [[help:exwm-init][exwm-init]]) when creating the Emacs frame.

#+begin_src emacs-lisp
  (use-package exwm
    :straight
    (exwm :type git
          :host github
          :repo "ch11ng/exwm")
    :defer t)
#+end_src

*** Desktop-environment (useful with EXWM)

This package sets up volume keys, brightness keys, and a screen
locker.  I like i3lock, and want it to use my theme's background
colour.

#+begin_src emacs-lisp
  (use-package desktop-environment
    :straight t
    :delight
    :hook
    (exwm-init . desktop-environment-mode)
    :config
    <<custom-screenlock-command>>
    (defadvice desktop-environment-lock-screen
        (before change-bg-color activate)
      (custom-screenlock-command))
    (desktop-environment-mode))
#+end_src

**** Change screenlock command based on theme colour

#+name: custom-screenlock-command
#+begin_src emacs-lisp :tangle no
  (defun custom-screenlock-command ()
    "Change the value of `desktop-environment-screenlock-command'
  to run i3lock with the background colour of the current theme."
    (let ((color (face-attribute 'default :background)))
      (setq desktop-environment-screenlock-command
            (format "i3lock -c '%s' -n"
                    (with-temp-buffer
                      (insert (if
                                  (= (length color) 7)
                                  color
                                "#000000"))
                      (beginning-of-line)
                      (delete-char 1)
                      (buffer-string))))))
#+end_src

** "Applications"

*** Vterm

A performant terminal emulator in Emacs.  Unfortunately, it still
doesn't play nice with complicated things such as NetHack.

#+begin_src emacs-lisp
  (use-package vterm
    :straight t
    :defer t
    :config
    <<eshell/vterm>>)
#+end_src

**** Launch a vterm from eshell

The function =eshell/vterm= starts a program in vterm from eshell.

#+name: eshell/vterm
#+begin_src emacs-lisp :tangle no
  (defun eshell/vterm (&rest args)
    "Launch a program from eshell using vterm."
    (let ((vterm-shell
           (eshell-flatten-and-stringify args)))
      (vterm)))
#+end_src

*** Libmpdee

An mpd library.  I use it only for random/shuffle.

#+begin_src emacs-lisp
  (use-package libmpdee
    :straight t
    :when (executable-find "mpd")
    :defer t)
#+end_src

*** MPDel

A more flexible mpd client than mingus.

#+begin_src emacs-lisp
  (use-package mpdel
    :straight t
    :when (executable-find "mpd")
    :bind-keymap
    ("s-m" . mpdel-core-map)
    :bind
    ("s-a" . mpdel-core-open-albums)
    ("<XF86AudioPlay>" . libmpdel-playback-play-pause)
    ("<XF86AudioPrev>" . libmpdel-playback-previous)
    ("<XF86AudioNext>" . libmpdel-playback-next)
    (:map mpdel-core-map
          ("Z" . mpd-shuffle-playlist)
          ("z" . mpd-toggle-random)
          ("C-d" . mpdel-core-open-directories)))
#+end_src

*** Transmission

An Emacs front-end for the [[http://www.transmissionbt.com/][Transmission]] BitTorrent daemon.  In the [[*EWW][EWW]]
section, I bind the function [[help:transmission-add-url-at-point][transmission-add-url-at-point]] in
eww-mode.

#+begin_src emacs-lisp
  (use-package transmission
    :straight t
    :when (executable-find "transmission-daemon")
    :defer t
    :commands transmission-mode
    :init
    (defun transmission-add-url-at-point (url &optional directory)
      "Adds torrent if point is on a magnet or torrent link.
  With prefix arg, prompt for DIRECTORY in which to download."
      (interactive (list (shr-url-at-point nil)
                         (when current-prefix-arg
                           (read-directory-name "Download in: " "~/Downloads/"))))
      (transmission-add url directory))
    (defun open-transmission-in-this-window ()
      (interactive)
      (let ((buffer (get-buffer-create "*transmission*")))
        (switch-to-buffer buffer)
        (transmission-mode)
        (revert-buffer)
        (cd (expand-file-name "~/Downloads"))))
    :bind
    ("C-z C-t" . open-transmission-in-this-window))
#+end_src

*** Elpher

Elpher is a gopher and gemini browser for Emacs.

I add an entry in [[help:browse-url-handlers][browse-url-handlers]] so that gopher links are opened
in Elpher (this does not work from eww).  This requires creating a new
function which can accept the extra arguments.

#+begin_src emacs-lisp
  (use-package elpher
    :straight t
    :defer t
    :commands elpher-go
    :init
    (defun elpher-go-please (url &rest _ignore)
      "Like `elpher-go', but allows extra arguments.
  This is useful for `browse-url-handlers'"
      (elpher-go url))
    (with-eval-after-load 'browse-url
      (add-to-list 'browse-url-handlers
                   '("^\\(gopher\\|gemini\\)://" . elpher-go-please))))
#+end_src

**** Elpher org-link support                                           :mine:

My own library to provide org-link support for elpher.

Hosted [[https://git.jamzattack.xyz/ol-elpher][here]].

#+begin_src emacs-lisp
  (use-package ol-elpher
    :straight
    (ol-elpher :type git
               :repo "git@jamzattack.xyz:ol-elpher.git")
    :after ol)
#+end_src

*** EBDB

EBDB is a contact management system for Emacs.  BBDB is used more
often, but I chose EBDB because it has plenty of
[[info:ebdb#Top][documentation]].

I set up =ebdb-gnus= and =ebdb-message= to activate when gnus and
message are loaded, because EBDB provides integration with these
libraries.  By default, it gets in the way a lot -- opening up buffers
of contacts whenever you read or write mail.

- Setting [[help:ebdb-mua-pop-up][ebdb-mua-pop-up]] to nil means that
  a buffer will only show in gnus when =; ;= is pressed.
- Setting
  [[help:ebdb-completion-display-record][ebdb-completion-display-record]]
  to nil stops the buffer from showing when using address completion
  while composing mail.

I also prefer to keep my contacts file encrypted, so I set
[[help:ebdb-sources][ebdb-sources]] accordingly.

#+begin_src emacs-lisp
  (use-package ebdb
    :straight
    (:host github :repo "girzel/ebdb")
    :defer t
    :custom
    (ebdb-mua-pop-up nil)
    (ebdb-sources
     (expand-file-name
      "ebdb.gpg" user-emacs-directory))
    (ebdb-completion-display-record nil)
    :init
    (with-eval-after-load 'gnus
      (require 'ebdb-gnus))
    (with-eval-after-load 'message
      (require 'ebdb-message)))
#+end_src

*** Magit

I've finally been convinced that Magit is the one true way to use git.
Currently, the config is quite simple -- open magit in the current
buffer, and show 20 recent commits instead of 10.

#+begin_src emacs-lisp
  (use-package magit
    :straight t
    :custom
    (magit-display-buffer-function
     #'magit-display-buffer-same-window-except-diff-v1)
    (magit-log-section-commit-count 20)
    :bind
    ("C-x g" . magit-status))
#+end_src

** Appearance

*** Rainbow-delimiters

Minor mode that highlights parentheses well.

#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :straight t
    :defer t
    :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

*** Dimmer (dim inactive buffers)

Dims inactive buffers, so that you can more clearly see which window
you're in (sometimes the mode-line just doesn't cut it).

#+begin_src emacs-lisp
  (use-package dimmer
    :straight t
    :hook
    (after-init . dimmer-mode)
    :config
    (setq dimmer-fraction 0.3)
    (dimmer-mode t)
    (dimmer-configure-org)
    (dimmer-configure-magit)
    (dimmer-configure-helm)
    (dimmer-configure-gnus))
#+end_src

** Quality of life

*** Scratch

Scratch allows you to create a scratch buffer - either in the major
mode of the current buffer, or (with prefix arg) in the major mode of
your choice.

#+begin_src emacs-lisp
  (use-package scratch
    :straight t
    :bind
    ("C-z s" . scratch)
    ("C-z C-s" . scratch))
#+end_src

*** Edwina

Edwina provides some rudimentary [[https://dwm.suckless.org][dwm]]
emulation.  The function
[[help:edwina-setup-dwm-keys][edwina-setup-dwm-keys]] binds similar
keys to what dwm actually uses.

#+begin_src emacs-lisp
  (use-package edwina
    :straight t
    :defer t
    :config
    (edwina-setup-dwm-keys 'super))
#+end_src

*** 0x0

Provides some functions to upload to [[http://0x0.st][0x0.st]].

#+begin_src emacs-lisp
  (use-package 0x0
    :straight t
    :defer t)
#+end_src

*** Plumb                                                              :mine:

A way to open URLs the way I want.  I bind it to =C-z d=.  Some commands
from this package are bound in the [[*EWW][EWW]] section.

Hosted [[https://git.jamzattack.xyz/plumb][here]].

#+begin_src emacs-lisp
  (use-package plumb
    :straight
    (plumb :type git
           :flavor melpa
           :repo "git@jamzattack.xyz:plumb.git")
    :bind
    ("C-z d" . plumb)
    ("C-z C-d" . plumb))
#+end_src

*** Narrow-x                                                           :mine:

My own package providing a few extra
[[info:emacs#Narrowing][narrowing]] commands.

Hosted [[https://git.jamzattack.xyz/narrow-x][here]].

#+begin_src emacs-lisp
  (use-package narrow-x
    :straight
    (narrow-x :type git
              :repo "git@jamzattack.xyz:narrow-x.git")
    :bind
    (:map narrow-map
          ("h" . narrow-to-paragraph)
          ("M-n" . narrow-to-next-paragraph)
          ("M-p" . narrow-to-prev-paragraph)
          ("DEL" . narrow-to-prev-page)
          ("SPC" . narrow-to-next-page)
          ("b" . narrow-to-prev-defun)
          ("f" . narrow-to-next-defun)))
#+end_src

*** Search-query                                                       :mine:

My own search query package.  It simply provides a few functions so
that I don't need to use DuckDuckGo's bangs, and for websites that
don't have a bang.

Unfortunately, [[https://invidio.us][invidio.us]] is due to [[https://omar.yt/posts/stepping-away-from-open-source][shut down]] on <2020-09-01 Tue>, so
I use a mirror.

Hosted [[https://git.jamzattack.xyz/search-query][here]].

#+begin_src emacs-lisp
  (use-package search-query
    :straight
    (search-query :type git
                  :repo "git@jamzattack.xyz:search-query")
    :custom
    (search-query-tpb-mirror "piratebay.live")
    (search-query-invidious-mirror "invidious.13ad.de")
    :bind
    ("C-z a" . search-archwiki)
    ("C-z t" . search-tpb)
    ("C-z y" . search-invidious)		; just youtube really
    ("C-z w" . search-wikipedia)
    ("C-z C-w" . search-wiktionary)
    ("C-z C-e" . search-etymonline))
#+end_src

** Dired

A couple of packages that enhance dired.

*** Dired-async

Make dired run actions in the background.  This is in the package
=async=.

#+begin_src emacs-lisp
  (use-package dired-async
    :straight async
    :defer t
    :config
    (dired-async-mode))
#+end_src

*** Dired-subtree

Recursively list directories and cycle like org-mode.  Bind =TAB= to
show/hide a subtree, and disable the predefined faces.  Part of the
=dired-hacks= package.

#+begin_src emacs-lisp
  (use-package dired-subtree
    :straight dired-hacks
    :after dired
    :demand t
    :custom
    (dired-subtree-use-backgrounds nil)
    :bind
    (:map dired-mode-map
          ("TAB" . dired-subtree-cycle)))
#+end_src

** Eshell

Eshell packages

*** Eshell outline mode                                                :mine:

My own package to integrate [[help:outline-minor-mode][outline-minor-mode]] with [[*Eshell][eshell]].

Hosted [[https://git.jamzattack.xyz/eshell-outline][here]].

#+begin_src emacs-lisp
  (use-package eshell-outline
    :straight
    (eshell-outline :type git
                    :flavor melpa
                    :repo "git@jamzattack.xyz:eshell-outline.git")
    :hook (eshell-mode . eshell-outline-mode))
#+end_src

*** Fish completion

Fish completion allows eshell and shell buffers to use [[https://fishshell.com/][fish]]
completion.  Fish must be installed.

#+begin_src emacs-lisp
  (use-package fish-completion
    :straight t
    :after eshell
    :when (executable-find "fish")
    :config
    (global-fish-completion-mode))
#+end_src

** System-packages

System-packages allows updating, installing, and removing programs
installed with your system's package manager.

#+begin_src emacs-lisp
  (use-package system-packages
    :straight t
    :defer t)
#+end_src

** Not really useful

*** Lorem Ipsum

A /Lorem Ipsum/ generator.

#+begin_src emacs-lisp
  (use-package lorem-ipsum
    :straight t
    :defer t)
#+end_src

# Local Variables:
# indent-tabs-mode: nil
# End:
