#+title: Emacs Configuration
#+author: Jamie Beardslee
#+email: beardsleejamie@gmail.com
#+property: header-args:emacs-lisp :tangle lisp/config.el :noweb yes :results none

This is my Emacs config file.  It is written in org-mode so that I can
brag about how dope org-mode is.  [[file:README.org][This file]] contains my main
configuration, which is tangled to [[file:lisp/config.el][config.el]].  [[file:init.el][init.el]] sets the
variable =custom-file= to [[file:lisp/custom.el][custom.el]], loads [[file:lisp/config.el][config.el]], and then loads
[[file:lisp/custom.el][custom.el]].

Note: [[file:lisp/custom.el][custom.el]] should not be edited manually, as it is used by Emacs
for settings changed using the customisation interface.

My own packages and other things that I need to =require= are housed
in [[file:lisp][lisp/]].  I don't include the [[file:straight][straight/]] directory so the first
startup will take some time.

* Startup

Get some things out of the way early.  Without [[*Straight][straight]] or
[[*Use-package and dependencies][use-package]], none of this config would work.

** Straight

Install [[https://github.com/raxod502/straight.el][straight.el]].  It gets a lot of hype, so I'm trying to use it
instead of the built-in =package.el=.  It has a use-package keyword,
so you can simply (re)define a package like so:

#+begin_src emacs-lisp :tangle no
  (use-package package-name
    :straight
    (package-name :host gitlab
                  :repo "user/forked-package"
                  :branch "cool-new-feature"))
#+end_src

This snippet clones and loads straight, stolen from the README.

#+begin_src emacs-lisp
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  (setq straight-vc-git-default-protocol 'ssh)
  (add-to-list 'straight-built-in-pseudo-packages 'org)
#+end_src

** Use-package and dependencies

Install use-package using =straight-use-package=, and load both
=use-package= and =bind-key=.  Note =bind-key= is a dependency of
=use-package=, so I don't need to install it manually.

I also use use-package's =:delight= keyword, so install that as well.
I don't need to use =(require delight)= as use-package handles that.

#+begin_src emacs-lisp
  (straight-use-package 'use-package)
  (straight-use-package 'delight)
  (setq use-package-compute-statistics t)
  (require 'use-package)
  (require 'bind-key)
#+end_src

** Fonts

The function =set-up-font-please= loads my [[file:lisp/fonts.el][font settings]].  Call it
when creating a new frame or starting emacs.

#+begin_src emacs-lisp
  (defun set-up-fonts-please ()
    (interactive)
    (load (expand-file-name "lisp/fonts.el" user-emacs-directory)))

  (add-hook 'server-after-make-frame-hook 'set-up-fonts-please)
  (add-hook 'window-setup-hook 'set-up-fonts-please)
#+end_src

** Keybindings

*** Prefix keys

A couple of prefix keys.  It's useful to set these up early, so that
you don't get any errors i.e "C-z is not a valid prefix key".

**** Remove =C-z=

Unbind =C-z= before anything else, so that I can use it as a prefix
key.

#+begin_src emacs-lisp
  (global-unset-key (kbd "C-z"))
#+end_src

**** Alias <menu> to C-x

Make the menu key do the same as =C-x=.

#+begin_src emacs-lisp
  (bind-key "<menu>" ctl-x-map)
#+end_src

*** Reloading config file

Reload [[file:lisp/config.el][config file]].  This is done with =bind-key= so that it is
recorded in the variable =personal-keybindings=.

#+begin_src emacs-lisp
  (bind-key "C-c r" 'config-load)
#+end_src

* Built-in packages

This is the section for built-in packages.

** package.el

It's useful to keep =package.el= updated for the functions
=describe-package= and =list-packages=.  All my packages are now
installed using [[*Straight][straight]], so disable the function =package-install=.

#+begin_src emacs-lisp
  (use-package package
    :no-require t
    :config
    (setq package-archives
          '(("gnu" . "http://elpa.gnu.org/packages/")
            ("melpa" . "http://melpa.org/packages/")))
    (fmakunbound 'package-install))
#+end_src

** Major editing modes

Major modes for text editing.  For non-editing major modes, see
[[Applications]]

*** Org Mode

Open source blocks and stuff in the current window.  Use tab from the
language's major mode inside source blocks.  Open everything in Emacs,
and use eww for html instead of mhtml-mode.

#+begin_src emacs-lisp
  (use-package org
    :defer t
    :custom
    (org-src-window-setup 'current-window)
    (org-src-tab-acts-natively t)
    (org-adapt-indentation nil)
    (org-file-apps
     '((auto-mode . emacs)
       ("\\.x?html?\\'" . (lambda (file &optional ignore)
                            (eww-open-file file)))))
    :delight
    (org-src-mode " #+src")
    :bind
    (:map org-mode-map
          ("M-h" . mark-paragraph)
          ("C-M-h" . org-mark-element)))
#+end_src

**** Org Capture

Take notes in org-mode with specific templates and write them to a
file.  Similar to remember.

#+begin_src emacs-lisp
  (use-package org-capture
    :custom
    (org-default-notes-file "~/org/notes.org")
    (org-capture-templates
     '(("t" "Todo")
       ("tt" "Misc." entry
        (file+headline "todo.org" "Miscellaneous")
        "* TODO %?\n\n%a\n")
       ("tu" "University" entry
        (file+headline "todo.org" "University")
        "* TODO %?\n\n%a\n")
       ("n" "Notes" entry
        (file+headline "notes.org" "Notes")
        "* %?\nEntered on %u\n\n%i\n\n%a\n")
       ("m" "Music" entry
        (file+headline "notes.org" "Music")
        "* %?\nEntered on %u\n\n%i\n")
       ("e" "Elisp" entry
        (file+headline "notes.org" "Emacs Lisp")
        "* %^{Title}\n\n#+begin_src emacs-lisp\n %i\n#+end_src\n")
       ("d" "Diary" entry
        (file "diary.org")
        "* %?\nEntered on %u\n\n")))
    (org-capture-bookmark nil)
    :bind
    ("C-x M-r" . org-capture))
#+end_src

**** Org babel

Work with code blocks.  The libraries all provide support for a
language so that you can run their source blocks with =C-c C-c=.

***** LilyPond

Execute LilyPond source blocks.  For notes about exporting to pdf, see
[[https://gitlab.com/jamzattack/lilypond/-/raw/master/org/lilypond.org][this org file]].  Only load it when lilypond is installed.

#+begin_src emacs-lisp
  (use-package ob-lilypond
    :when (executable-find "lilypond")
    :defer t
    :commands org-babel-execute:lilypond)
#+end_src

***** C

Execute C source blocks.  [[http://bellard.org/tcc/][TCC]] is a really fast compiler, so use it
instead of gcc if it's installed.

#+begin_src emacs-lisp
  (use-package ob-C
    :defer t
    :commands org-babel-execute:C
    :custom
    (org-babel-C-compiler
     (or (executable-find "tcc")
         "gcc")))
#+end_src

***** Scheme

Execute scheme source blocks.  This uses [[*Geiser][Geiser]] which is kind of
awkward and slow, but evaluating scheme is useful.

#+begin_src emacs-lisp
  (use-package ob-scheme
    :defer t
    :commands org-babel-execute:scheme)
#+end_src

***** Common Lisp

Execute Common Lisp source blocks.  This depends on [[*SLIME][Slime]], which
doesn't start automatically (see the variable =slime-auto-start=).

#+begin_src emacs-lisp
  (use-package ob-lisp
    :defer t
    :commands org-babel-execute:lisp)
#+end_src

***** Shell

Execute shell source blocks.  Autoload =sh=, =shell=, and =bash=
functions.

#+begin_src emacs-lisp
  (use-package ob-shell
    :defer t
    :commands
    org-babel-execute:sh
    org-babel-execute:shell
    org-babel-execute:bash)
#+end_src

**** Org links

The library org-mode uses to create and store links.  I bind =C-x M-l=
to generate a link from the current position.

#+begin_src emacs-lisp
  (use-package ol
    :bind
    ("C-x M-l" . org-store-link))
#+end_src

**** Org agenda

Use all files in =org-directory= to get my agenda.  And don't disrupt
my window configuration.

#+begin_src emacs-lisp
  (use-package org-agenda
    :defer t
    :after org
    :custom
    (org-agenda-files (list (or org-directory
                                "~/org")))
    (org-agenda-window-setup 'current-window)
    :bind
    ("C-z C-a" . org-agenda))
#+end_src

*** Prolog

Major mode for editing prolog files.  Files ending in =.pl= open in
=prolog-mode=.

#+begin_src emacs-lisp
  (use-package prolog
    :mode ("\\.pl\\'" . prolog-mode))
#+end_src

*** Cc-mode

Set the C style to bsd, which uses tabs.  Use Java/Awk indentation for
Java/Awk files.

#+begin_src emacs-lisp
  (use-package cc-mode
    :defer t
    :custom
    (c-default-style '((java-mode . "java")
                       (awk-mode . "awk")
                       (other . "bsd"))))
#+end_src

*** Emacs Lisp mode

Make the scratch buffer use =emacs-lisp-mode=.  Note: Most of my Elisp
keybindings are now in my package [[https://gitlab.com/jamzattack/selime][selime]].

#+begin_src emacs-lisp
  (use-package elisp-mode
    :custom
    (initial-major-mode 'emacs-lisp-mode)
    :delight
    (emacs-lisp-mode "el" :major)
    (inferior-emacs-lisp-mode "EL>" :major)
    :bind
    ("<C-M-backspace>" . backward-kill-sexp))
#+end_src

**** Find-func

A package that defines a few functions for editing Elisp source code.
It provides the function =find-function-setup-keys= which binds some
keys in =ctl-x-map=, but I prefer to have them under =C-h=.

#+begin_src emacs-lisp
  (use-package find-func
    :defer t
    :bind
    (:map help-map
          ("C-l" . find-library)
          ("C-f" . find-function)
          ("C-v" . find-variable)
          ("C-k" . find-function-on-key)))
#+end_src

*** Typesetting

**** Nroff-mode

Set a compile-command hook for =nroff= files.  I usually use the ms
macros when writing something, but I usually just use org-mode anyway.

#+begin_src emacs-lisp
  (use-package nroff-mode
    :defer t
    :config
    <<nroff-mode-compile>>
    :hook (nroff-mode . nroff-mode-compile))
#+end_src

***** Compile Command

#+name: nroff-mode-compile
#+begin_src emacs-lisp :tangle no
  (defun nroff-mode-compile ()
    "Set the compile command for nroff files.

  It will choose the macro set based on the file extension."
    (let* ((in (buffer-file-name))
           (out (concat (file-name-sans-extension in)
                        ".pdf")))
      (setq-local
       compile-command
       (format "groff -%s -Tpdf '%s' > '%s'"
               (file-name-extension in) in out))))
#+end_src

**** LaTeX

Set a compile-command hook for latex files.  I prefer to write in
org-mode, but compiling latex on its own is sometimes useful.

#+begin_src emacs-lisp
  (use-package tex-mode
    :defer t
    :config
    <<latex-compile-command>>
    :hook (latex-mode . latex-compile-command))
#+end_src

***** Compile Command

#+name: latex-compile-command
#+begin_src emacs-lisp :tangle no
  (defun latex-compile-command ()
    "Set the compile command for latex files."
    (setq-local compile-command
                (format "pdflatex %s" buffer-file-name)))
#+end_src

** Minor modes

Minor modes that help with anything Emacs, be it programming, writing
emails, or anything else that Emacs can do.

*** Compile

Bind =C-z RET= and =f9= to compile.

#+begin_src emacs-lisp
  (use-package compile
    :bind
    ("C-z C-m" . compile)
    ("<f9>" . recompile))
#+end_src

*** Hi-lock

I often use =M-s h .= to see where variables, functions, etc. are
used.  However, paredit remaps =M-s= to =paredit-splice-sexp=, so I
turn on hi-lock-mode which enables the =C-x w= prefix.

#+begin_src emacs-lisp
  (use-package hi-lock
    :delight
    :config
    (global-hi-lock-mode t))
#+end_src

*** Parens

Highlight matching parens everywhere.

#+begin_src emacs-lisp
  (use-package paren
    :config
    (show-paren-mode t))
#+end_src

*** Auto fill

Instead of "Fill", show "^M" (carriage return) in the mode-line.

#+begin_src emacs-lisp
  (use-package simple
    :delight
    (auto-fill-function " ^M"))
#+end_src

*** Isearch

Instead of "ISearch", show "^S" =(kbd "C-s")= in the mode-line.

#+begin_src emacs-lisp
  (use-package isearch
    :delight " ^S")
#+end_src

*** Eldoc

Eldoc is what provides the function signature in the mode-line when
editing Elisp.  By default, it waits for 0.5 seconds so I bump the
delay down to 0.

#+begin_src emacs-lisp
  (use-package eldoc
    :delight
    :defer t
    :custom
    (eldoc-idle-delay 0))
#+end_src

** Applications

This section is for Elisp programs that have an interface of their
own, rather than being just a major/minor mode.

*** EWW

Elisp web browser - I just set some variables to make eww the default
browser, and change the width to 80 columns.

#+begin_src emacs-lisp
  (use-package eww
    :defer t
    :custom
    (eww-bookmarks-directory
     (expand-file-name "eww" user-emacs-directory))
    :init
    (with-eval-after-load "browse-url"
      (setq browse-url-browser-function 'eww-browse-url
            browse-url-secondary-browser-function 'browse-url-externally-please))
    (with-eval-after-load "shr"
      (setq shr-width 80
            shr-use-colors nil
            shr-use-fonts nil))
    <<browse-url-externally-please>>
    :bind
    (:map eww-mode-map
          ("f" . plumb-stream)
          ("D" . plumb-download-video)
          ("A" . plumb-audio)
          ("m" . transmission-add-url-at-point)
          ("V" . variable-pitch-mode)))
#+end_src

**** External browser

#+name: browse-url-externally-please
#+begin_src emacs-lisp :tangle no
  (defun browse-url-externally-please (url &optional ignored)
    "Open URL using either vimb or surf if they are found,
  otherwise use xdg-open."
    (interactive (browse-url-interactive-arg "URL: "))
    (call-process (or (executable-find "vimb")
                      (executable-find "surf")
                      (executable-find "xdg-open"))
                  nil 0 nil url))
#+end_src

*** ERC

The only reason for this to be here is to set my nick.

#+begin_src emacs-lisp
  (use-package erc
    :defer t
    :custom
    (erc-nick "jamzattack")
    (erc-hide-list '("JOIN" "PART" "QUIT"))
    :config
    (add-to-list 'erc-modules 'notifications)
    (erc-track-mode))
#+end_src

**** ERC notifications

erc-notify enables notifications for erc conversations.  I only enable
it if the executable "dunst" is found, because it will crash Emacs
unless a notification daemon is active.

#+begin_src emacs-lisp
  (use-package erc-notify
    :after erc
    :config
    (when (executable-find "dunst")
      (erc-notify-enable)))
#+end_src

*** Ibuffer

Ibuffer is an interface similar to dired, but for editing your open
buffers.  I don't use it much now in favour of [[*Helm][Helm]], but it can be
useful for more complex filtering.

#+begin_src emacs-lisp
  (use-package ibuffer
    :bind
    ("C-x C-b" . ibuffer)
    :init
    (defun ibuffer-helm-major-mode-predicate (buffer)
      "Returns t if BUF is a helm buffer."
      (equal 'helm-major-mode
             (with-current-buffer buffer
               major-mode)))
    :config
    (add-to-list 'ibuffer-maybe-show-predicates
                 #'ibuffer-helm-major-mode-predicate))
#+end_src

*** Dired

Group directories first.  This works only with GNU ls, so don't use
this if you use a different version.

#+begin_src emacs-lisp
  (use-package dired
    :defer t
    :config
    (setq dired-listing-switches "-lahv --group-directories-first")
    :init
    (setq delete-by-moving-to-trash t)
    :bind
    ("C-x C-d" . dired-jump))
#+end_src

*** Diffing

**** Ediff

By default, Ediff tries to open its own frame.  This doesn't work well
with EXWM, so I disable that feature.

#+begin_src emacs-lisp
  (use-package ediff
    :defer t
    :custom
    (ediff-window-setup-function
     #'ediff-setup-windows-plain))
#+end_src

**** Smerge

Easily merge git conflicts.  The prefix is =C-c ^= which works fine,
but I also bind =C-c n= and =C-c p= to go to the next/previous hunk.

#+begin_src emacs-lisp
  (use-package smerge-mode
    :bind
    (:map smerge-mode-map
          ("C-c n" . smerge-next)
          ("C-c p" . smerge-prev)))
#+end_src

** Shells

Shells in Emacs - both shell and eshell settings are here.

*** Shell

I don't want the shell buffer to open a new window, so add an entry in
=display-buffer-alist=.

#+begin_src emacs-lisp
  (use-package shell
    :defer t
    :config
    (add-to-list 'display-buffer-alist
                 '("^\\*shell\\*$" display-buffer-same-window)))
#+end_src

*** Eshell

Change the history size to 1000, custom keybinding to either
delete-char or kill-buffer like a "normal" shell.

#+begin_src emacs-lisp
  (use-package eshell
    :custom
    (eshell-history-size 1000)
    :init
    <<open-or-bury-eshell>>
    :bind
    ("s-e" . open-or-bury-eshell)
    (:map eshell-mode-map
          ("C-d" . eshell-delete-or-quit)
          ([remap eshell-display-modifier-help] . eshell-mark-output)
          ("C-c M-o" . eshell/clear-please))
    :config
    (require 'esh-mode)
    <<eshell-delete-or-quit>>
    <<eshell/clear-please>>
    <<eshell/e>>
    <<eshell/comint>>)
#+end_src

**** Eshell functions

***** Open or bury eshell

Open an eshell buffer or bury the current one.

#+name: open-or-bury-eshell
#+begin_src emacs-lisp :tangle no
  (defun open-or-bury-eshell (&optional arg)
    "Launch or bury an eshell buffer.

  Prefix arg ARG is passed to `eshell'.  If current buffer is an
  eshell buffer, bury it."
    (interactive "P")
    (cond (arg
           (eshell arg))
          ((equal major-mode 'eshell-mode)
           (bury-buffer))
          (t
           (eshell arg))))
#+end_src

***** Delete or quit

If point is at an empty prompt, kill the buffer.  Otherwise, delete
char.

#+name: eshell-delete-or-quit
#+begin_src emacs-lisp :tangle no
  (defun eshell-delete-or-quit (arg)
    "If point is at the end of the buffer and input is empty,
  kill the buffer.  Just like giving EOF to a normal shell."
    (interactive "p")
    (if (=
         (save-excursion
           (eshell-bol)
           (point))
         (point)
         (point-max))
        (kill-buffer (current-buffer))
      (delete-char arg)))
#+end_src

***** Clear screen

Clear the screen, but keep current input intact.  If a command is
running, keep the output of that command on screen.

#+name: eshell/clear-please
#+begin_src emacs-lisp :tangle no
  (defun eshell/clear-please ()
    "Similar to `eshell/clear', but keeps the current input."
    (interactive)
    (save-excursion
      (if (equal eshell-command-running-string "**")
          (eshell-next-prompt -1)
        (eshell-bol))
      (end-of-line 0)
      (insert (make-string (window-height) ?\n))))
#+end_src

***** Edit a file

Instead of opening a file with =emacsclient=, just edit it directly.

#+name: eshell/e
#+begin_src emacs-lisp :tangle no
  (defun eshell/e (&rest args)
    "Edit a file from eshell."
    (mapcar 'find-file args))
#+end_src

***** Comint

A wrapper to start a comint process from eshell.

Used like so:
#+begin_example sh
comint ed ~/.bashrc
#+end_example

#+name: eshell/comint
#+begin_src emacs-lisp :tangle no
  (defun eshell/comint (&rest args)
    "Start a comint session running ARGS"
    (let ((string (eshell-flatten-and-stringify args))
          (program (executable-find (car args)))
          (program-args (eshell-flatten-and-stringify (cdr args))))
      (switch-to-buffer
       (make-comint string
                    (or program
                        (user-error "Executable %s not found" (car args)))
                    nil
                    program-args))))
#+end_src

** Saving the state of Emacs

Packages that save where you were - recentf saves a list of edited
files, and desktop saves a list of variables and current buffers.

*** Recentf

This package saves a list of recently visited files.  I've had some
problems with Helm not loading the recentf list, so it is done here.

#+begin_src emacs-lisp
  (use-package recentf
    :config (recentf-load-list))
#+end_src

*** Desktop

Save list of buffers and some variables when exiting Emacs.  Don't
save a list of frames, that just ends up spamming me with extra frames
everywhere.

#+begin_src emacs-lisp
  (use-package desktop
    :custom
    (desktop-restore-frames nil)
    (history-delete-duplicates t)
    (desktop-save-mode t)
    :config
    (add-to-list 'desktop-globals-to-save 'helm-ff-history)
    (add-to-list 'desktop-globals-to-save 'extended-command-history))
#+end_src

*** Winner-mode

Saves window configurations so that you can use =C-c <left>= to undo
changes in window arrangement.

#+begin_src emacs-lisp
  (use-package winner
    :config
    (winner-mode))
#+end_src

** Interface tweaks

Some settings for the UI of Emacs - mode-line, scroll-bar, etc.

*** Extraneous bars

Section for the three wasteful bars -- tool bar, menu bar, and scroll
bar.

**** Scroll bar

Disable the scroll bar using =customize=, but set the width in case I
decide to turn it on.

#+begin_src emacs-lisp
  (use-package scroll-bar
    :custom
    (scroll-bar-mode nil)
    (scroll-bar-width 6 t))
#+end_src

**** Menu bar

Disable the menu bar.

#+begin_src emacs-lisp
  (use-package menu-bar
    :config
    (menu-bar-mode -1))
#+end_src

**** Tool bar

Disable the tool bar.

#+begin_src emacs-lisp
  (use-package tool-bar
    :config
    (tool-bar-mode -1))
#+end_src

*** Mode-line

**** Time

Display the current time in the mode-line, and make it use 24-hour
time.

#+begin_src emacs-lisp
  (use-package time
    :custom
    (display-time-24hr-format t)
    :config
    (display-time-mode t))
#+end_src

**** Battery

Show battery information with =C-z b=.

#+begin_src emacs-lisp
  (use-package battery
    :bind
    ("C-z b" . battery))
#+end_src

**** Show the column

Show the current column in the mode-line.  This is provided by the
=simple= package.

#+begin_src emacs-lisp
  (use-package simple
    :config
    (column-number-mode t))
#+end_src

*** Keybindings

A couple of keybindings to change the way lines are displayed.

**** Line wrapping

Simple keybinding to wrap/unwrap lines.  This feature is also provided
by =simple=.

#+begin_src emacs-lisp
  (use-package simple
    :bind
    ("C-c t" . toggle-truncate-lines))
#+end_src

**** Line numbers

Display line numbers.  I prefer to just use the mode-line because it
doesn't slow down Emacs as much.

#+begin_src emacs-lisp
  (use-package display-line-numbers
    :bind
    ("C-c l" . display-line-numbers-mode))
#+end_src

**** Cycle spacing

By default, =M-SPC= is bound to the less powerful =just-one-space=.  I
rebind that key to =cycle-spacing=, which does the same thing but on
successive invocations switches between one space and no spaces.
Thus, =M-SPC M-SPC= acts like =M-\= (=delete-horizontal-space=)

#+begin_src emacs-lisp
  (use-package simple
    :bind
    ("M-SPC" . cycle-spacing))
#+end_src

** Environment variables

Set the =$EDITOR= to =emacsclient=.  Because I (almost) only use other
programs from within Emacs, this works.  If you don't use EXWM it
would be advisable to set this in =~/.xinitrc=.  Also set =$PAGER= to
=cat= for programs launched from Emacs, helpful with eshell because
some programs automatically output to the pager.

#+begin_src emacs-lisp
  (use-package env
    :config
    (setenv "EDITOR" "emacsclient")
    (setenv "PAGER" "cat"))
#+end_src

** Windows

Libraries related to Emacs windows.  Not to be confused
with the operating system.

*** Window

=bury-buffer= is a very useful function so I bind it to =C-z C-z=, a
pretty accessible key.

For purely pedantic reasons, I also bind =C-x _= to =shrink-window=.
Why does =shrink-window-horizontally= have a keybinding by default but
=shrink-window= doesn't?

#+begin_src emacs-lisp
  (use-package window
    :bind
    ("C-z C-z" . bury-buffer)
    ("C-x _" . shrink-window))
#+end_src

*** Windmove

Bind =s-{c,h,t,n}= to switch window more easily.  I use dvorak, so
this is like ={i,j,k,l}= on a qwerty keyboard.

#+begin_src emacs-lisp
  (use-package windmove
    :defer t
    :bind
    ("s-c" . windmove-up)
    ("s-h" . windmove-left)
    ("s-t" . windmove-down)
    ("s-n" . windmove-right))
#+end_src

*** Tab-bar

I've started using =tab-bar-mode= instead of exwm workspaces.  I don't
like the tab bar to be shown all the time, so I hide it.

I also add advice to show the current tab and index in the echo area.
Somewhat awkwardly, a similar message is also shown by default when
=tab-bar-mode= is nil.  I prefer my less subtle message, but I might
remove this in the future -- maybe show it in the mode-line instead?

The keybindings =s-g= and =s-r= move to the previous or next tab
respectively, which fits well with my windmove keybindings.  =s-w= is
the default keybinding in exwm to switch workspace, so I reuse the key
to switch tab.

#+begin_src emacs-lisp
  (use-package tab-bar
    :defer t
    :custom
    (tab-bar-show nil)
    (tab-bar-close-button-show nil)
    (tab-bar-new-button-show nil)
    (tab-bar-tab-hints t)
    :bind
    ("s-g" . tab-previous)
    ("s-r" . tab-next)
    ("s-w" . tab-bar-switch-to-tab)
    :config
    (dolist (k (number-sequence 0 9))
      (bind-key (kbd (format "s-%s" k)) 'tab-bar-select-tab))
    (defadvice tab-bar-select-tab
        (after show-tab-name activate)
      "Show the tab name and index+1 in the echo area."
      (message "Switched to tab: %s (%s)"
               (propertize
                (cdr (assoc 'name (tab-bar--tab)))
                'face 'error)
               (1+ (tab-bar--current-tab-index)))))
#+end_src

** View-mode

I like using view-mode and scroll-lock-mode is kind-of useless, so I
rebind Scroll_Lock to toggle view-mode and enable view-mode if a
buffer is read-only.

Also bind some keys to simplify movement.

#+begin_src emacs-lisp
  (use-package view
    :custom (view-read-only t)
    :bind
    ("<Scroll_Lock>" . view-mode)
    (:map view-mode-map
          ("l" . recenter-top-bottom)
          ("f" . forward-sexp)
          ("b" . backward-sexp)))
#+end_src

** Fixing some default behaviour

Tweak some default behaviour that pisses me off.

*** Swap yes/no prompt with y/n

Typing yes/no is an inconvenience that can be avoided.  Alias it to
y/n.  This would be wrapped in =(use-package subr ...)= but that isn't
requirable.

#+begin_src emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
  (bind-key "RET" 'y-or-n-p-insert-y y-or-n-p-map)
#+end_src

*** Enable all the features

Disable the annoying "This is an advanced feature" thing.  It seems so
dumb that this feature exists.

#+begin_src emacs-lisp
  (use-package novice
    :custom
    (disabled-command-function nil))
#+end_src

*** Disable audible and visual bell

Don't ring the damn bell.  This is provided by the file "terminal.c"
which isn't a loadable feature, so use custom instead.

#+begin_src emacs-lisp
  (use-package custom
    :custom
    (ring-bell-function 'ignore))
#+end_src

** Theme

Allow themes to be loaded from the [[file:lisp/themes][lisp/themes]] directory, allow all
themes to be loaded, then load my [[file:lisp/themes/custom-theme.el][custom theme]].

#+begin_src emacs-lisp
  (use-package custom
    :custom
    (custom-theme-directory
     (expand-file-name "lisp/themes" user-emacs-directory))
    (custom-safe-themes t)
    (custom-enabled-themes '(custom)))
#+end_src

** Convenience

Some convenience features.

*** Hippie expand

Hippie-expand is a slightly more useful replacement for
dabbrev-expand.  It can make use of multiple sources, including
filenames, kill-ring, and dabbrev.

#+begin_src emacs-lisp
  (use-package hippie-exp
    :defer t
    :bind
    ("M-/" . hippie-expand))
#+end_src

*** Paragraphs

Bind =M-n= and =M-p= to move by paragraph.  I used to do this on a
per-mode basis, but that got annoying.  These functions are defined in
=paragraphs.el= which isn't a loadable feature, so I use =(use-package
emacs)= instead.

#+begin_src emacs-lisp
  (use-package emacs
    :bind
    ("M-n" . forward-paragraph)
    ("M-p" . backward-paragraph))
#+end_src

** Mail

*** Gnus

I've finally managed to make the switch to gnus.  Frankly, my main
motivation was to avoid setting up notmuch again with my university
email.

As far as I can tell, using a maildir with gnus is a hassle -- so I'm
just using IMAP.

#+begin_src emacs-lisp
  (use-package gnus
    :init
    (setq mail-user-agent 'gnus-user-agent)
    :config
    (setq gnus-select-method
          '(nntp "news.gwene.org"))
    (setq gnus-secondary-select-methods
          '((nnimap "gmail"
                    (nnimap-address "imap.gmail.com"))
            (nnimap "university"
                    (nnimap-address "outlook.office365.com"))
            (nntp "news.eternal-september.org"
                  (nntp-authinfo-file "~/.authinfo.gpg"))))
    :bind
    ("C-z C-n" . gnus-unplugged)
    ("C-z n" . gnus))
#+end_src

**** Gnus-sum

Nicer summary & thread formatting.  Credit to [[https:protesilaos.com][Protesilaos Stavrou]]

#+begin_src emacs-lisp
  (use-package gnus-sum
    :defer t
    :custom
    (gnus-summary-line-format "%U%R%z %-16,16&user-date;  %4L:%-30,30f  %B%s\n")
    (gnus-summary-mode-line-format "%p")
    (gnus-sum-thread-tree-false-root "─┬> ")
    (gnus-sum-thread-tree-indent " ")
    (gnus-sum-thread-tree-leaf-with-other "├─> ")
    (gnus-sum-thread-tree-root "")
    (gnus-sum-thread-tree-single-leaf "└─> ")
    (gnus-sum-thread-tree-vertical "│"))
#+end_src

**** Gnus-msg

Gnus' library for sending messages.  =gnus-posting-styles= allows you
to adjust headers, signatures, etc. based on how you got to the
composition buffer.  All messages composed from my university mailbox
will be sent from my university address.  Very nice!

[[info:gnus#Posting Styles][Posting Styles in the gnus manual]]

#+begin_src emacs-lisp
  (use-package gnus-msg
    :defer t
    :custom
    (gnus-posting-styles
     '(("nnimap\\+university:.*"
        (From "Jamie Beardslee <beardsjami@myvuw.ac.nz>")
        (signature "Jamie Beardslee (300484191)")))))
#+end_src

**** Gnus-art

Article stuff.  Gnus tries to use the =smiley= library to convert
emoticons into images -- I turned it off becaus it looks terrible.

I also want some buttons to show signature status and alternative MIME
types, which is achieved with =gnus-buttonized-mime-types=.

#+begin_src emacs-lisp
  (use-package gnus-art
    :defer t
    :custom
    (gnus-treat-display-smileys nil)
    (gnus-buttonized-mime-types
     '("multipart/signed" "multipart/alternative")))
#+end_src

**** Gnus-topic

Gnus can sort your groups by topic, which I enable in
=gnus-group-mode-hook=.

It shows titles for empty topics by default, which I find to get in
the way.  I set the variable =gnus-topic-display-empty-topics= to
disable this.  Default behaviour can be restored with =T H=.

#+begin_src emacs-lisp
  (use-package gnus-topic
    :defer t
    :custom
    (gnus-topic-display-empty-topics nil)
    :hook
    (gnus-group-mode . gnus-topic-mode))
#+end_src

**** Gnus-start

Just getting rid of a couple of extra files in $HOME.

- Gnus by default creates =~/.newsrc= in a format compatible with
  other newsreaders, but I don't use any so it's just an extra line in
  my ls.
- Move the /dribble/ (i.e. auto-save) files to =~/.cache=.

#+begin_src emacs-lisp
  (use-package gnus-start
    :defer t
    :custom
    (gnus-save-newsrc-file nil)
    (gnus-dribble-directory "~/.cache/"))
#+end_src

*** Sendmail

Sending mail.  I use [[https://marlam.de/msmtp/][msmtp]] to send mail because it works well with
multiple smtp servers.  I tried using [[info:smtpmail#Top][smtpmail]] but couldn't get it to
switch between the two easily.

I set it up to use the from header to determine how to send mail.

#+begin_src emacs-lisp
  (use-package sendmail
    :defer t
    :config
    (setq send-mail-function 'sendmail-send-it
          sendmail-program (or "msmtp"
                               "sendmail")
          mail-envelope-from 'header))
#+end_src

*** MIME

Stuff to do with MIME

**** mm-decode

The library responsible for decoding mime parts.  I prefer reading
text/plain, so discourage the other common alternatives.  I also want
to verify messages that have a signature, so I set =mm-verify-option=.

#+begin_src emacs-lisp
  (use-package mm-decode
    :defer t
    :custom
    (mm-discouraged-alternatives
     '("text/html" "text/richtext"))
    (mm-verify-option 'known))
#+end_src

**** mml-sec

Yay for encryption.  I set up messages to encrypt to myself as well as
the recipient, and sign with the sender.

#+begin_src emacs-lisp
  (use-package mml-sec
    :defer t
    :custom
    (mml-secure-openpgp-encrypt-to-self t)
    (mml-secure-openpgp-sign-with-sender t))
#+end_src

* My packages

Not necessarily /my/ packages, but packages that are in the [[file:lisp/][lisp]]
directory.

** Internet

A selection of packages to facilitate searching and browsing the web
within Emacs.

*** Library-genesis

My custom package for searching library genesis.  I bind =C-z l= to a
search.

Located [[file:lisp/library-genesis/library-genesis.el][here]].

#+begin_src emacs-lisp
  (use-package library-genesis
    :load-path "lisp/library-genesis"
    :bind
    ("C-z l" . library-genesis-search))
#+end_src

*** Search-query

My own search query package.  It simply provides a few functions so
that I don't need to use DuckDuckGo's bangs, and for websites that
don't have a bang.

Located [[file:lisp/search-query/search-query.el][here]].

#+begin_src emacs-lisp
  (use-package search-query
    :load-path "lisp/search-query"
    :custom
    (tpb-mirror "piratebay.live")
    :bind
    ("C-z t" . tpb-search)
    ("C-z y" . youtube-search)
    ("C-z w" . wikipedia-search)
    ("C-z C-w" . wiktionary-word))
#+end_src

*** Reddit-browse

This is a very minimal package to ease the use of reddit within eww.
It uses the old reddit mobile site, which works well with eww.

Located [[file:lisp/reddit-browse/reddit-browse.el][here]].

#+begin_src emacs-lisp
  (use-package reddit-browse
    :load-path "lisp/reddit-browse"
    :custom
    (reddit-subreddit-list '("emacs" "lisp" "lispmemes"
                             "vxjunkies" "linux" "nethack"
                             "cello" "throwers"))
    :bind
    ("C-z r" . reddit-goto-subreddit))
#+end_src

** Toggle-touchpad

A simple package I wrote to toggle the touchpad/trackpoint on my
ThinkPad

Located [[file:lisp/toggle-touchpad/toggle-touchpad.el][here]].

#+begin_src emacs-lisp
  (use-package toggle-touchpad
    :load-path "lisp/toggle-touchpad"
    :bind
    ("<XF86TouchpadToggle>" . toggle-touchpad)
    ("C-z \\" . toggle-touchpad))
#+end_src

** LilyPond-mode

I copied lilypond-mode into my custom directory for the machines that
don't have lilypond installed.

Located [[file:lisp/lilypond-mode][here]].

#+begin_src emacs-lisp
  (use-package lilypond-mode
    :load-path "lisp/lilypond-mode"
    :delight
    (LilyPond-mode "ly" :major)
    :init
    (defalias 'lilypond-mode 'LilyPond-mode)
    (defun custom-lilypond-setup ()
      "Sets the buffer's compile command and comment-column."
      (hack-local-variables)
      (unless (or (file-exists-p "Makefile")
                  (local-variable-p 'compile-command (current-buffer)))
        (setq-local compile-command
                    (format "lilypond %s" buffer-file-name)))
      (setq-local comment-column 0))
    :mode ("\\.ly\\'" . LilyPond-mode)
    :hook (LilyPond-mode . custom-lilypond-setup))
#+end_src

** Arch Linux settings

This file just adds a few =auto-mode-alist= entries for systemd and
pacman files.

Located [[file:lisp/arch-linux-settings/arch-linux-settings.el][here]].

#+begin_src emacs-lisp
  (use-package arch-linux-settings
    :load-path "lisp/arch-linux-settings")
#+end_src

** Custom EXWM config

My custom settings for EXWM - not much different from the
=exwm-config-default=, but doesn't get in my way as much.  It provides
the function =custom-exwm-config= which is run when exwm starts.

Note: this doesn't actually start EXWM, so this needs to be done in
your [[file:~/.xinitrc][xinitrc]].

Located [[file:lisp/exwm/custom-exwm-config.el][here]].

#+begin_src emacs-lisp
  (use-package custom-exwm-config
    :load-path "lisp/exwm"
    :commands custom-exwm-config
    :hook
    (exwm-init . custom-exwm-config))
#+end_src

** Miscellaneous functions

A number of functions that don't necessarily have a proper home.  Bind
=C-c p= to open the pdf output of a typesetting program, and =C-h M-a=
to run the external "apropos" command (not to be confused with Elisp
apropos).

Located [[file:lisp/my-misc-defuns/my-misc-defuns.el][here]].

#+begin_src emacs-lisp
  (use-package my-misc-defuns
    :load-path "lisp/my-misc-defuns"
    :bind
    ("C-M-\\" . indent-region-or-defun-please)
    ("C-h M-a" . system-apropos)
    ("C-c p" . open-pdf-of-current-file))
#+end_src

** Helm

My own bits of Lisp to enhance Helm.

*** Bookmarks

This package defines a macro to create new bookmark sources, and adds
a few.

Located [[file:lisp/helm/custom-helm-bookmark.el][here]].

#+begin_src emacs-lisp
  (use-package custom-helm-bookmark
    :load-path "lisp/helm"
    :after helm
    :custom
    (helm-bookmark-default-filtered-sources
     '(helm-source-bookmark-university
       helm-source-bookmark-config
       helm-source-bookmark-org-misc
       helm-source-bookmark-elisp
       helm-source-bookmark-downloads
       helm-source-bookmark-magit
       helm-source-bookmark-elfeed
       helm-source-bookmark-dired
       helm-source-bookmark-info
       helm-source-bookmark-man
       helm-source-bookmark-other
       helm-source-bookmark-set)))
#+end_src

* Third party packages

This is where the packages installed with [[https://github.com/raxod502/straight.el][straight.el]] are located.
All of these use the =:straight= keyword, so that they are downloaded
if they aren't already.

** HELM

Rebind a few keys in order to make use of Helm's features.  Stuff like
=find-file= and =switch-to-buffer=.  Also remap =C-x k= to
kill-this-buffer, because I use helm-mini to kill other buffers.

I also bind =M-C-y= to =helm-show-kill-ring=.  I tried to use this to
replace =yank-pop= but the latter is too engrained in my fingers.

#+begin_src emacs-lisp
  (use-package helm
    :straight t
    :custom
    (helm-completion-style 'emacs)
    (helm-describe-variable-function 'helpful-variable)
    (helm-describe-function-function 'helpful-callable)
    (helm-buffer-max-length 24)
    (helm-split-window-preferred-function
     #'helm-split-window-please)
    (helm-external-programs-associations
     '(("midi" . "timidity")
       ("png" . "sxiv")
       ("jpg" . "sxiv")
       ("gif" . "mpv -L")
       ("mp4" . "mpv")
       ("mkv" . "mpv")
       ("avi" . "mpv")
       ("webm" . "mpv")))
    :init
    <<kill-this-buffer-please>>
    :config
    <<helm-split-window-please>>
    (require 'helm-config)
    (delight '((helm-mode "")))
    (helm-mode t)
    :bind
    ("M-x" . helm-M-x)
    ("<menu><menu>" . helm-M-x)
    ("M-o" . helm-occur)
    ("s-b" . helm-mini)
    ("C-x b" . helm-mini)
    ("C-x k" . kill-this-buffer-please)
    ("C-x C-f" . helm-find-files)
    ("C-x r b" . helm-filtered-bookmarks)
    ("M-C-y" . helm-show-kill-ring)
    (:map helm-map
          ("C-h c" . describe-key-briefly)))
#+end_src

*** Functions

**** Kill buffer

I rebind =C-x k= to kill the current buffer, because =helm-mini= is so
useful.  If buffer is in the list =buffers-to-bury=, bury it instead
of killing.

#+name: kill-this-buffer-please
#+begin_src emacs-lisp :tangle no
  (defvar buffers-to-bury '("*scratch*" "#emacs" "*Messages*")
    "List of buffers to bury instead of kill with the function
  `kill-this-buffer-please'")

  (defun kill-this-buffer-please ()
    "Actually kill this buffer, unlike `kill-this-buffer' which
  sometimes doesn't work."
    (interactive)
    (if (member (buffer-name) buffers-to-bury)
        (bury-buffer)
      (kill-buffer (current-buffer))))
#+end_src

**** Split window

The way Helm splits windows can get in the way a bit.  This more
predictable function selects the largest non-exwm window.

#+name: helm-split-window-please
#+begin_src emacs-lisp :tangle no
  (defun helm-split-window-please (window)
    "If the frame only has one window, split it.  Otherwise, select
  the largest non-exwm window."
    (if (one-window-p t)
        (split-window (selected-window) nil
                      (if (> (window-pixel-width) (window-pixel-height))
                          'right
                        'below))
      (select-window
       ;; Reworking of `get-largest-window', doesn't choose an exwm
       ;; window.
       (let ((best-size 0)
             best-window size)
         (dolist (window (window-list-1 nil 'nomini))
           (when (and (not (window-dedicated-p window))
                      (not (eq window (selected-window)))
                      (not (equal
                            (buffer-local-value
                             'major-mode (window-buffer window))
                            'exwm-mode)))
             (setq size (* (window-pixel-height window)
                           (window-pixel-width window)))
             (when (> size best-size)
               (setq best-size size)
               (setq best-window window))))
         best-window))))
#+end_src

*** Helm Imenu

Helm's interface to imenu.  It shows more information than =imenu=
does, and also provides a way to access an imenu for multiple buffers.

Note: I use =:bind*= because LilyPond-mode tries to bind =C-c i=.

#+begin_src emacs-lisp
  (use-package helm-imenu
    :straight helm
    :defer t
    :bind*
    ("C-c i" . helm-imenu)
    ("C-c I" . helm-imenu-in-all-buffers))
#+end_src

*** Helm man

Remap =C-h C-m= to =helm-man-woman=, a Helm interface for selecting
manpages.

#+begin_src emacs-lisp
  (use-package helm-man
    :defer t
    :straight helm
    :custom
    (man-width 80)
    :bind
    (:map help-map
          ("C-m" . helm-man-woman)))
#+end_src

*** Helm system packages

Provides an abstraction layer for viewing and installing system
packages.

#+begin_src emacs-lisp
  (use-package helm-system-packages
    :straight t
    :bind
    (:map help-map
          ("C-p" . helm-system-packages)))
#+end_src

*** Helm Notmuch

A Helm interface for Notmuch.  Load it after both Helm and Notmuch (of
course).

#+begin_src emacs-lisp
  (use-package helm-notmuch
    :straight t
    :defer t)
#+end_src

*** Helm eww

Some Helm functions for eww.  I replace all the default functions with
the Helm alternatives.

#+begin_src emacs-lisp
  (use-package helm-eww
    :straight t
    :bind
    ("C-x r e" . helm-eww-bookmarks)
    (:map eww-mode-map
          ("B" . helm-eww-bookmarks)
          ("H" . helm-eww-history)
          ("S" . helm-eww-buffers)))
#+end_src

*** Helm org

=C-c M-o= in org-mode runs the function =helm-org-in-buffer-headings=.
Similar to =occur=, but only shows headings.

#+begin_src emacs-lisp
  (use-package helm-org
    :straight t
    :after org
    :bind
    (:map org-mode-map
          ("C-c M-o" . helm-org-in-buffer-headings)))
#+end_src

** Helpful

Helpful gives a whole lot more information than =describe-*=.  I also
bind =C-h SPC= to helpful-at-point, just to save a keypress here and
there.  The =:straight= recipe uses my fork, which doesn't depend on
=f.el=.  (I know it's minor, but I'd rather not load the extra
library).

#+begin_src emacs-lisp
  (use-package helpful
    :straight
    (helpful :type git
             :flavor melpa
             :host gitlab
             :repo "jamzattack/helpful"
             :branch "no-f")
    :config
    <<helpful-edit-source-temporarily>>
    <<helpful-copy-to-kill-ring>>
    :bind
    (:map help-map
          ("f" . helpful-callable)
          ("v" . helpful-variable)
          ("o" . helpful-symbol)
          ("k" . helpful-key)
          ("SPC" . helpful-at-point))
    (:map helpful-mode-map
          ("e" . helpful-edit-source-temporarily)
          ("w" . helpful-copy-to-kill-ring)))
#+end_src

*** Edit source

A function that opens up a new buffer with the source shown in the
current =helpful= buffer.

I still want to make this work with C source code, but that's not
nearly as useful anyway.

#+name: helpful-edit-source-temporarily
#+begin_src emacs-lisp :tangle no
  (defun helpful-edit-source-temporarily ()
    "Edit the source of a function, variable, or macro in its own
  buffer.  You need to already be in a helpful buffer."
    (interactive)
    (save-excursion
      (let* ((name
              (format "*%s <helpful edit>"
                      helpful--sym))
             (buffer (get-buffer-create name))
             (min (progn
                    (goto-char (point-min))
                    (re-search-forward "^Source Code$")
                    (forward-line 1)
                    (point)))
             (max (progn
                    (goto-char min)
                    (end-of-defun)
                    (point))))
        (copy-to-buffer buffer
                        min
                        max)
        (pop-to-buffer buffer)
        (emacs-lisp-mode))))
#+end_src

*** Save symbol to kill ring

#+name: helpful-copy-to-kill-ring
#+begin_src emacs-lisp :tangle no
  (defun helpful-copy-to-kill-ring (buffer)
    "Copy the callable or variable of BUFFER to the kill ring.

  Called interactively, BUFFER is the current buffer or, with
  prefix arg, read from the minibuffer."
    (interactive (list
                  (if current-prefix-arg
                      (read-buffer "Copy symbol from buffer: "
                                   (current-buffer)
                                   t
                                   (lambda (name)
                                     (string-match
                                      "^\\*helpful"
                                      name)))
                    (current-buffer))))
    (with-current-buffer buffer
      (unless (eq major-mode 'helpful-mode)
        (user-error "%s is not a helpful buffer" (buffer-name buffer)))
      (kill-new (symbol-name helpful--sym))
      (message "\"%s\" saved to kill ring." helpful--sym)))
#+end_src

** Major Modes

*** Nov.el - epub in emacs

Read epub files in Emacs.  I set this up as the default mode for
epubs, and set the default width to 80 columns.

#+begin_src emacs-lisp
  (use-package nov
    :straight t
    :custom
    (nov-text-width 80)
    :mode ("\\.epub\\'" . nov-mode))
#+end_src

*** PDF-tools

Majorly increases performance when viewing pdfs within Emacs, and
provides some note-taking facilities.

#+begin_src emacs-lisp
  (use-package pdf-tools
    :straight t
    :magic ("%PDF" . pdf-view-mode)
    :custom
    (pdf-links-browse-uri-function #'pdf-links-open-please)
    :hook
    (pdf-view-mode . auto-revert-mode)
    :config
    <<pdf-links-open-please>>
    (pdf-tools-install))
#+end_src

**** Custom link handler

Awkward hacky workaround to get LilyPond's links to open properly.

#+name: pdf-links-open-please
#+begin_src emacs-lisp :tangle no
  (defun pdf-links-open-please (uri)
    "Open \"textedit://\" links via `find-file', and jump to the
  right point.  I use this because lilypond output contains such
  links."
    (cond ((string-match "textedit://" uri)
           (let* ((path
                   ;; get rid of textedit://
                   (replace-regexp-in-string
                    "^textedit://"
                    ""
                    uri))
                  (split
                   (split-string path ":"))
                  (file
                   (apply #'concat
                          (butlast split 3)))
                  (extras
                   (reverse
                    (cdr split)))
                  (line
                   (string-to-number
                    (caddr extras)))
                  (column
                   (string-to-number
                    (car extras)))
                  (buffer
                   (find-file-noselect file)))
             (pop-to-buffer buffer)
             (goto-char (point-min))
             (forward-line (1- line))
             (move-to-column column)))
          (t
           (pdf-links-browse-uri-default uri))))
#+end_src

*** Markdown

A very featureful major mode for markdown files.  I only really use it
for looking at READMEs though, so I add view-mode to the hook.

#+begin_src emacs-lisp
  (use-package markdown-mode
    :straight t
    :mode "*\\.md'"
    :hook (markdown-mode . view-mode))
#+end_src

*** GNU APL mode

I've been trying to learn a bit of APL recently, and =gnu-apl-mode= is
an excellent way to get into it.  It tries to use the super modifier
to insert special characters, but I use it for my own functions so I
set the prefix to ". ".

#+begin_src emacs-lisp
  (use-package gnu-apl-mode
    :straight t
    :mode
    "\\.apl'"
    :custom
    (gnu-apl-interactive-mode-map-prefix ". ")
    (gnu-apl-mode-map-prefix ". "))
#+end_src

** Programming

*** Geiser

Interact with scheme in a powerful and emacsy way.  I set the scheme
program name (which isn't actually a part of geiser) to whichever
scheme is installed, in order of preference.

#+begin_src emacs-lisp
  (use-package geiser
    :straight t
    :defer t
    :delight
    (scheme-mode "scm" :major)
    (geiser-repl-mode "SCM>" :major)
    (geiser-autodoc-mode)
    :hook
    (geiser-repl-mode . paredit-mode)
    :custom
    (scheme-program-name
     (or (executable-find "guile3.0")
         (executable-find "guile")
         (executable-find "chez")
         (executable-find "mit-scheme")
         "scheme"))
    (geiser-default-implementation 'guile)
    (geiser-repl-history-filename "~/.cache/geiser/history"))
#+end_src

*** SLIME

Interact with Common Lisp in a powerful and emacsy way.  I set the
default Lisp program, add some fancier stuff such as a nicer REPl, and
move the history file out of =$HOME=.

#+begin_src emacs-lisp
  (use-package slime
    :straight t
    :delight
    (lisp-mode "cl" :major)
    (slime-repl-mode "CL>" :major)
    (slime-mode)
    (slime-autodoc-mode)
    :init
    (autoload 'slime-switch-to-output-buffer "slime-repl")
    (defun disable-slime-completion ()
      (setq slime-completion-at-point-functions
            '(slime-simple-completion-at-point)))
    :hook (slime-connected . disable-slime-completion)
    :custom
    (inferior-lisp-program
     (or (executable-find "sbcl")
         (executable-find "ccl")
         (executable-find "clisp")
         "lisp"))
    (slime-contribs '(slime-fancy))
    (slime-repl-history-file "~/.cache/slime/history")
    (common-lisp-hyperspec-root
     (if (file-exists-p "/usr/share/doc/HyperSpec/")
         "file:///usr/share/doc/HyperSpec/"
       "http://clhs.lisp.se/"))
    (slime-auto-start 'ask)
    :bind
    (:map slime-mode-map
          ("C-c C-z" . slime-switch-to-output-buffer)))
#+end_src

*** Paredit

Efficient and clever editing commands for working with s-expressions.
Enabled for Lisp modes only.

#+begin_src emacs-lisp
  (use-package paredit
    :straight t
    :defer t
    :delight
    :hook
    (emacs-lisp-mode . paredit-mode)
    (lisp-interaction-mode . paredit-mode)
    (ielm-mode . paredit-mode)
    (eval-expression-minibuffer-setup . paredit-mode)
    (lisp-mode . paredit-mode)
    (slime-repl-mode . paredit-mode)
    (scheme-mode . paredit-mode))
#+end_src

*** Elf-mode

Major mode for viewing ELF files (compiled binaries).  I don't use it
often, but it's nice to be able to see what a program does sometimes.

#+begin_src emacs-lisp
  (use-package elf-mode
    :straight t
    :magic ("ELF" . elf-mode))
#+end_src

*** Selime

This is my package to make Elisp evaluation and documentation lookup a
bit more like Slime.  It's often not necessary, but sometimes I find
myself using =C-c C-d C-f= to describe an Elisp function, etc.

Hosted [[https://gitlab.com/jamzattack/selime][here]].

#+begin_src emacs-lisp
  (use-package selime
    :straight
    (selime :type git
            :flavor melpa
            :host gitlab
            :repo "jamzattack/selime")
    :hook (emacs-lisp-mode . selime-mode))
#+end_src

*** LilyPond auto-insert

My own package to handle auto-insertions for LilyPond-mode.  I add it
to =LilyPond-mode-hook=.

Hosted [[https://gitlab.com/jamzattack/lilypond-auto-insert][here]].

#+begin_src emacs-lisp
  (use-package lilypond-auto-insert
    :straight
    (lilypond-auto-insert :type git
                          :host gitlab
                          :flavor melpa
                          :repo "jamzattack/lilypond-auto-insert")
    :defer t
    :custom
    (lilypond-auto-insert-language "english")
    :hook
    (LilyPond-mode . lilypond-auto-insert-on-empty-buffer))
#+end_src

** Org

*** Github markdown

Export to markdown.

#+begin_src emacs-lisp
  (use-package ox-gfm
    :straight t
    :defer t)
#+end_src

*** Html export

Export to html.

#+begin_src emacs-lisp
  (use-package htmlize
    :straight t
    :defer t)
#+end_src

*** Org web tools

This package parses a web page and transforms it into beautiful
org-mode.  I use it in my package [[*Plumb][plumb]].

#+begin_src emacs-lisp
  (use-package org-web-tools
    :straight t
    :defer t)
#+end_src

** EXWM - Emacs X Window Manager

Manipulate X windows as Emacs buffers.  As mentioned [[*Custom EXWM config][earlier]], you need
to enable exwm (via =exwm-init=) when creating the Emacs frame.

#+begin_src emacs-lisp
  (use-package exwm
    :straight t
    :defer t)
#+end_src

*** Desktop-environment (useful with EXWM)

This package sets up volume keys, brightness keys, and a screen
locker.  I like i3lock, and want it to use my theme's background
colour.

#+begin_src emacs-lisp
  (use-package desktop-environment
    :straight t
    :delight
    :init
    :config
    <<custom-screenlock-command>>
    (defadvice desktop-environment-lock-screen
        (before change-bg-color activate)
      (custom-screenlock-command))
    (desktop-environment-mode))
#+end_src

**** Change screenlock command based on theme colour

#+name: custom-screenlock-command
#+begin_src emacs-lisp :tangle no
  (defun custom-screenlock-command ()
    "Change the value of `desktop-environment-screenlock-command'
  to run i3lock with the background colour of the current theme."
    (let ((color (face-attribute 'default :background)))
      (setq desktop-environment-screenlock-command
            (format "i3lock -c '%s' -n"
                    (with-temp-buffer
                      (insert (if
                                  (= (length color) 7)
                                  color
                                "#000000"))
                      (beginning-of-line)
                      (delete-char 1)
                      (buffer-string))))))
#+end_src

** "Applications"

*** Vterm

A performant terminal emulator in Emacs.  Unfortunately, it still
doesn't play nice with complicated things such as NetHack.

#+begin_src emacs-lisp
  (use-package vterm
    :straight t
    :defer t
    :config
    <<eshell/vterm>>)
#+end_src

**** Launch a vterm from eshell

The function =eshell/vterm= starts a program in vterm from eshell.

#+name: eshell/vterm
#+begin_src emacs-lisp :tangle no
  (defun eshell/vterm (&rest args)
    "Launch a program from eshell using vterm."
    (let ((vterm-shell
           (eshell-flatten-and-stringify args)))
      (vterm)))
#+end_src

*** Libmpdee

An mpd library.  I use it only for random/shuffle.

#+begin_src emacs-lisp
  (use-package libmpdee
    :straight t
    :when (executable-find "mpd")
    :defer t)
#+end_src

*** MPDel

A more flexible mpd client than mingus.

#+begin_src emacs-lisp
  (use-package mpdel
    :straight t
    :when (executable-find "mpd")
    :bind-keymap
    ("s-m" . mpdel-core-map)
    :bind
    ("s-a" . mpdel-core-open-albums)
    ("<XF86AudioPlay>" . libmpdel-playback-play-pause)
    ("<XF86AudioPrev>" . libmpdel-playback-previous)
    ("<XF86AudioNext>" . libmpdel-playback-next)
    (:map mpdel-core-map
          ("Z" . mpd-shuffle-playlist)
          ("z" . mpd-toggle-random)
          ("C-d" . mpdel-core-open-directories)))
#+end_src

*** Transmission

An Emacs front-end for the [[http://www.transmissionbt.com/][Transmission]] BitTorrent daemon.  In the [[*EWW][EWW]]
section, I bind the function =transmission-add-url-at-point= in
eww-mode.

#+begin_src emacs-lisp
  (use-package transmission
    :straight t
    :when (executable-find "transmission-daemon")
    :defer t
    :commands transmission-mode
    :init
    (defun transmission-add-url-at-point (url)
      "Adds torrent if point is on a magnet link"
      (interactive (list (shr-url-at-point nil)))
      (transmission-add url))
    (defun open-transmission-in-this-window ()
      (interactive)
      (let ((buffer (get-buffer-create "*transmission*")))
        (switch-to-buffer buffer)
        (transmission-mode)
        (revert-buffer)
        (cd (expand-file-name "~/Downloads"))))
    :bind
    ("C-z C-t" . open-transmission-in-this-window))
#+end_src

*** Elfeed

Elfeed is an RSS and Atom feed reader for Emacs, which functions
similarly to Notmuch.  To get the list of feeds, I decrypt the file
[[file:elfeed/feeds.gpg][feeds.gpg]].  I also bind the same keys as in [[* EWW][eww]].

#+begin_src emacs-lisp
  (use-package elfeed
    :straight t
    :defer t
    :bind
    (:map elfeed-show-mode-map
          ("l" . elfeed)
          ("f" . plumb-stream)
          ("D" . plumb-download-video)
          ("A" . plumb-audio)
          ("<backtab>" . shr-previous-link)
          ("TAB" . shr-next-link))
    (:map elfeed-search-mode-map
          ("r" . elfeed-switch-to-entry))
    :config
    (setq elfeed-feeds
          (let ((file (expand-file-name
                       "elfeed/feeds.gpg" user-emacs-directory)))
            (when (file-exists-p file)
              (with-temp-buffer
                (insert-file-contents file)
                (eval (read (current-buffer))))))
          elfeed-search-remain-on-entry t
          elfeed-db-directory (expand-file-name
                               "elfeed" user-emacs-directory))
    <<elfeed-macro>>
    <<elfeed-switch-to-entry>>
    (elfeed-update))
#+end_src

*** Elpher

Elpher is a gopher and gemini browser for Emacs.

I add an entry in =browse-url-handlers= so that gopher links are
opened in Elpher (this does not work from eww).  This requires
creating a new function which can accept the extra arguments.

#+begin_src emacs-lisp
  (use-package elpher
    :straight t
    :defer t
    :init
    (defun elpher-go-please (url &rest _ignore)
      "Like `elpher-go', but allows extra arguments.
  This is useful for `browse-url-handlers'"
      (elpher-go url))
    (with-eval-after-load "browse-url"
      (add-to-list 'browse-url-handlers
                   '("^\\(gopher\\|gemini\\)://" . elpher-go-please))))
#+end_src

**** Elfeed functions

***** Create new search functions

A macro to search for a specific tag, and a handful of functions to
search for my most useful tags.  Note: it's not possible to define a
macro and use it within a progn, the macro is wrapped in
=eval-when-compile=.

#+name: elfeed-macro
#+begin_src emacs-lisp :tangle no
  (eval-when-compile
    (defmacro elfeed-defun-tag-search (tag)
      "Define a function to search elfeed for TAG."
      `(defun ,(intern (concat "elfeed-search-" tag "-please")) ()
         ,(format "Search elfeed for all items with the tag \"%s\"." tag)
         (interactive)
         (kill-buffer (elfeed-search-buffer))
         (let ((elfeed-search-filter ,(concat "+" tag)))
           (elfeed)))))

  (elfeed-defun-tag-search "university")
  (elfeed-defun-tag-search "youtube")
  (elfeed-defun-tag-search "blog")
#+end_src

***** Switch to entry buffer

If there is an =elfeed-entry= buffer, switch to it.  Otherwise, open
the entry at point.

#+name: elfeed-switch-to-entry
#+begin_src emacs-lisp :tangle no
  (defun elfeed-switch-to-entry ()
    (interactive)
    (let ((buffer (get-buffer "*elfeed-entry*"))
          (entry (elfeed-search-selected :ignore-region)))
      (if buffer
          (switch-to-buffer buffer)
        (elfeed-search-show-entry entry))))
#+end_src

*** EBDB

EBDB is a contact management system for Emacs.  BBDB is used more
often, but I chose EBDB because it has plenty of [[info:ebdb#Top][documentation]].

I set up =ebdb-gnus= and =ebdb-message= to activate when gnus and
message are loaded, because EBDB provides integration with these
libraries.  By default, it gets in the way a lot -- opening up buffers
of contacts whenever you read or write mail.

- Setting =ebdb-mua-pop-up= to nil means that a buffer will only show
  in gnus when =; ;= is pressed.
- Setting =ebdb-completion-display-record= to nil stops the buffer
  from showing when using address completion while composing mail.

I also prefer to keep my contacts file encrypted, so I set
=ebdb-sources= accordingly.

#+begin_src emacs-lisp
  (use-package ebdb
    :straight t
    :defer t
    :custom
    (ebdb-mua-pop-up nil)
    (ebdb-sources
     (expand-file-name
      "ebdb.gpg" user-emacs-directory))
    (ebdb-completion-display-record nil)
    :init
    (with-eval-after-load "gnus"
      (require 'ebdb-gnus))
    (with-eval-after-load "message"
      (require 'ebdb-message)))
#+end_src

*** Magit

I've finally been convinced that Magit is the one true way to use git.
Currently, the config is quite simple -- open magit in the current
buffer, and show 20 recent commits instead of 10.

#+begin_src emacs-lisp
  (use-package magit
    :straight t
    :custom
    (magit-display-buffer-function
     #'magit-display-buffer-same-window-except-diff-v1)
    (magit-log-section-commit-count 20)
    :bind
    ("C-x g" . magit-status))
#+end_src

** Appearance

*** Rainbow-mode

This package highlights hex colours (also install =xterm-color= to use
in a terminal emulator).

#+begin_src emacs-lisp
  (use-package rainbow-mode
    :straight t
    :delight
    (rainbow-mode " 🌈")
    :bind
    ("C-c h" . rainbow-mode))
#+end_src

*** Rainbow-delimiters

Minor mode that highlights parentheses well.

#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :straight t
    :defer t
    :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

*** Dimmer (dim inactive buffers)

Dims inactive buffers, so that you can more clearly see which window
you're in (sometimes the mode-line just doesn't cut it).

#+begin_src emacs-lisp
  (use-package dimmer
    :straight t
    :custom
    (dimmer-fraction 0.3)
    :config
    (dimmer-mode t))
#+end_src

** Quality of life

*** Scratch

Scratch allows you to create a scratch buffer - either in the major
mode of the current buffer, or (with prefix arg) in the major mode of
your choice.

#+begin_src emacs-lisp
  (use-package scratch
    :straight t
    :bind
    ("C-z s" . scratch)
    ("C-z C-s" . scratch))
#+end_src

*** Edwina

Edwina provides some rudimentary [[https://dwm.suckless.org][dwm]] emulation.  The function
=edwina-setup-dwm-keys= binds similar keys to what dwm actually uses.

#+begin_src emacs-lisp
  (use-package edwina
    :straight t
    :defer t
    :config
    (edwina-setup-dwm-keys 'super))
#+end_src

*** 0x0

Provides some functions to upload to [[http://0x0.st][0x0.st]].

#+begin_src emacs-lisp
  (use-package 0x0
    :straight t
    :defer t)
#+end_src

*** Plumb

A way to open URLs the way I want.  I bind it to =C-z d=.  Some
commands from this package are bound in the [[*EWW][EWW]] and [[*Elfeed][Elfeed]].

Hosted [[https://gitlab.com/jamzattack/plumb.el][here]].

#+begin_src emacs-lisp
  (use-package plumb
    :straight
    (plumb :type git
           :flavor melpa
           :host gitlab
           :repo "jamzattack/plumb.el")
    :bind
    ("C-z d" . plumb)
    ("C-z C-d" . plumb))
#+end_src

** Dired

A couple of packages that enhance dired.

*** Dired-async

Make dired run actions in the background.  This is in the package
=async=.

#+begin_src emacs-lisp
  (use-package dired-async
    :straight async
    :defer t
    :config
    (dired-async-mode))
#+end_src

*** Dired-subtree

Recursively list directories and cycle like org-mode.  Bind =TAB= to
show/hide a subtree, and disable the predefined faces.  Part of the
=dired-hacks= package.

#+begin_src emacs-lisp
  (use-package dired-subtree
    :straight dired-hacks
    :custom
    (dired-subtree-use-backgrounds nil)
    :bind
    (:map dired-mode-map
          ("<tab>" . dired-subtree-toggle)))
#+end_src

** Fish completion

Fish completion allows eshell and shell buffers to use [[https://fishshell.com/][fish]]
completion.  Fish must be installed.

#+begin_src emacs-lisp
  (use-package fish-completion
    :straight t
    :after eshell
    :when (executable-find "fish")
    :config
    (global-fish-completion-mode))
#+end_src

** System-packages

System-packages allows updating, installing, and removing programs
installed with your system's package manager.

#+begin_src emacs-lisp
  (use-package system-packages
    :straight t
    :defer t)
#+end_src

** Not really useful

*** Lorem Ipsum

A /Lorem Ipsum/ generator.

#+begin_src emacs-lisp
  (use-package lorem-ipsum
    :straight t
    :defer t)
#+end_src

# Local Variables:
# indent-tabs-mode: nil
# End:
